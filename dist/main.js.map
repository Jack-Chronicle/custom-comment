{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings;\r\n\r\n    async onload() {\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        this.addCommand({\r\n            id: \"toggle-comment-template\",\r\n            name: \"Toggle Comment\",\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n    }\r\n\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n    }\r\n\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n    }\r\n\r\n    insertComment(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n\r\n        if (cursorIndex === -1) {\r\n            // Fallback: insert template and move cursor to start\r\n            editor.replaceSelection(template);\r\n            return;\r\n        }\r\n\r\n        // Remove {cursor} and track where it was\r\n        const before = template.slice(0, cursorIndex);\r\n        const after = template.slice(cursorIndex + \"{cursor}\".length);\r\n\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(before + after);\r\n\r\n        // Calculate the new cursor position\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length;\r\n\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n    }\r\n\r\n    toggleComment(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        // Default comment styles to check\r\n        const defaultStyles = [\r\n            { start: \"%%\", end: \"%%\" },\r\n            { start: \"<!--\", end: \"-->\" },\r\n            { start: \"//\", end: \"\" },\r\n        ];\r\n\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let text: string;\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        let line = editor.getLine(cursor.line);\r\n\r\n        // Helper to find word bounds at a given ch\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            const regex = /\\w+/g;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Helper to check if a string is commented with given markers\r\n        function isTextCommented(str: string, start: string, end: string) {\r\n            if (!start) return false;\r\n            if (end) {\r\n                return str.trim().startsWith(start) && str.trim().endsWith(end);\r\n            } else {\r\n                return str.trim().startsWith(start);\r\n            }\r\n        }\r\n        // Helper to check if cursor is inside a comment\r\n        function isCursorInsideComment(line: string, cursorCh: number, start: string, end: string) {\r\n            const startIdx = line.indexOf(start);\r\n            const endIdx = end ? line.lastIndexOf(end) : -1;\r\n            if (start && end) {\r\n                return startIdx !== -1 && endIdx !== -1 && cursorCh >= startIdx + start.length && cursorCh <= endIdx;\r\n            } else if (start) {\r\n                return startIdx !== -1 && cursorCh >= startIdx + start.length;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // If selection, operate as before\r\n        if (selection) {\r\n            text = selection;\r\n        } else {\r\n            // No selection: check if cursor is inside a word\r\n            wordBounds = getWordBounds(line, cursor.ch);\r\n            if (wordBounds) {\r\n                text = line.slice(wordBounds.start, wordBounds.end);\r\n                from = { line: cursor.line, ch: wordBounds.start };\r\n                to = { line: cursor.line, ch: wordBounds.end };\r\n            } else {\r\n                text = line;\r\n                from = { line: cursor.line, ch: 0 };\r\n                to = { line: cursor.line, ch: line.length };\r\n            }\r\n        }\r\n\r\n        // Check if selection or word/line is inside a comment (custom or default)\r\n        let usedStart = markerStart;\r\n        let usedEnd = markerEnd;\r\n        let inside = false;\r\n        if (markerStart && isTextCommented(text, markerStart, markerEnd)) {\r\n            inside = true;\r\n        } else {\r\n            for (const style of defaultStyles) {\r\n                if (style.start && isTextCommented(text, style.start, style.end)) {\r\n                    usedStart = style.start;\r\n                    usedEnd = style.end;\r\n                    inside = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (inside) {\r\n            // Remove comment markers\r\n            let uncommented = text;\r\n            let removedStartLen = 0;\r\n            if (usedStart) {\r\n                const re = new RegExp(`^\\\\s*${usedStart.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')}`);\r\n                const match = uncommented.match(re);\r\n                if (match) {\r\n                    removedStartLen = match[0].length;\r\n                }\r\n                uncommented = uncommented.replace(re, \"\");\r\n            }\r\n            if (usedEnd) {\r\n                const re = new RegExp(`${usedEnd.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')}\\\\s*$`);\r\n                uncommented = uncommented.replace(re, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            if (selection) {\r\n                editor.replaceSelection(uncommented);\r\n                editor.setSelection(from, { line: to.line, ch: to.ch - removedStartLen });\r\n            } else if (wordBounds) {\r\n                editor.replaceRange(uncommented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = Math.max(wordBounds.start, cursor.ch - removedStartLen);\r\n                editor.setCursor({ line: cursor.line, ch: newCh });\r\n            } else {\r\n                editor.setLine(cursor.line, uncommented);\r\n                const newCh = Math.max(0, cursor.ch - removedStartLen);\r\n                editor.setCursor({ line: cursor.line, ch: newCh });\r\n            }\r\n        } else {\r\n            // Add comment markers, preserving template spaces\r\n            let commented = before + text + after;\r\n            if (selection) {\r\n                editor.replaceSelection(commented);\r\n                const startOffset = before.length;\r\n                editor.setSelection(\r\n                    { line: from.line, ch: from.ch + startOffset },\r\n                    { line: to.line, ch: to.ch + startOffset }\r\n                );\r\n            } else if (wordBounds) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = cursor.ch + before.length;\r\n                editor.setCursor({ line: cursor.line, ch: newCh });\r\n            } else {\r\n                editor.setLine(cursor.line, commented);\r\n                editor.setCursor({ line: cursor.line, ch: cursor.ch + before.length });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            // Remove markers from the line\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\"\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addTextArea(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "CommentFormatPlugin", "CommentFormatSettingTab", "editor", "DEFAULT_SETTINGS", "template", "cursorIndex", "before", "after", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerStart", "markerEnd", "defaultStyles", "selection", "cursor", "text", "to", "wordBounds", "line", "getWordBounds", "ch", "regex", "match", "isTextCommented", "str", "start", "end", "isCursorInsideComment", "cursorCh", "startIdx", "endIdx", "usedStart", "usedEnd", "inside", "style", "uncommented", "removedStartLen", "re", "newCh", "commented", "startOffset", "isInside"]
}
