{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect, RangeSetBuilder } from '@codemirror/state';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default fallback comment styles for removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\n/**\r\n * Main plugin class for Custom Comments.\r\n * Handles command registration, settings, and comment toggling logic.\r\n */\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n    private _cleanupGuard: boolean = false;\r\n\r\n    /**\r\n     * Called when the plugin is loaded. Registers commands and settings tab.\r\n     */\r\n    async onload() {\r\n        logDev('Plugin loading...');\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        this.registerMarkerCommands();\r\n        // Removed: auto-cleanup event registration\r\n    }\r\n\r\n    /**\r\n     * Registers all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        if (force && this._markerCommandIds) {\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Register main toggle command\r\n        let mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Register additional marker commands if enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n        logDev('Marker commands registered:', this._markerCommandIds);\r\n    }\r\n\r\n    /**\r\n     * Loads plugin settings from disk.\r\n     */\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n        logDev('Settings loaded:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Saves plugin settings to disk.\r\n     */\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n        logDev('Settings saved:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n        logDev('Plugin reloaded');\r\n    }\r\n\r\n    /**\r\n     * Inserts a comment at the current cursor position using the template.\r\n     */\r\n    insertComment(editor: Editor) {\r\n        let template = this.settings.template;\r\n        let cursorIndex = template.indexOf(\"{cursor}\");\r\n        if (cursorIndex === -1) {\r\n            editor.replaceSelection(template);\r\n            logDev('Inserted template (no cursor placeholder)');\r\n            return;\r\n        }\r\n        let before = template.slice(0, cursorIndex).trim();\r\n        let after = template.slice(cursorIndex + \"{cursor}\".length).trim();\r\n        const commentText = `${before} ${after}`.replace(/\\s+/g, ' ').trim();\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(`${before}  ${after}`.replace(/\\s+/g, ' ').replace(' ', ' {cursor} '));\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length + 1;\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n        logDev('Inserted comment at cursor');\r\n    }\r\n\r\n    /**\r\n     * Toggles comment using a specific marker set, or the default template if none provided.\r\n     * Handles selection, word, and cursor modes robustly.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n        // --- Clamp helper ---\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        let markerStart: string, markerEnd: string;\r\n        let markerStartNormalized: string, markerEndNormalized: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start.trim();\r\n            markerEnd = markerSet.end.trim();\r\n            markerStartNormalized = markerSet.start.endsWith(' ')? markerSet.start : markerSet.start + ' ';\r\n            markerEndNormalized = markerSet.end.startsWith(' ')? markerSet.end : ' ' + markerSet.end;\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before.trim();\r\n            markerEnd = after.trim();\r\n            markerStartNormalized = markerStart + (markerStart && !markerStart.endsWith(' ')? ' ' : '');\r\n            markerEndNormalized = (markerEnd && !markerEnd.startsWith(' ')? ' ' : '') + markerEnd;\r\n        }\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let text: string;\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        let line = editor.getLine(cursor.line);\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        function isTextCommentedExact(str: string, start: string, end: string) {\r\n            if (!start) return false;\r\n            if (end) {\r\n                return str.startsWith(start) && str.endsWith(end);\r\n            } else {\r\n                return str.startsWith(start);\r\n            }\r\n        }\r\n        function scanForFirst(lines: string[], fromLine: number, fromCh: number, marker: string, opposite: string, direction: 'back' | 'forward'): { type: 'marker' | 'opposite' | null, pos: { line: number, ch: number } | null } {\r\n            const markerTrim = marker.trim();\r\n            const oppositeTrim = opposite.trim();\r\n            if (direction === 'back') {\r\n                for (let l = fromLine; l >= 0; l--) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : line.length;\r\n                    for (let idx = searchStart - 1; idx >= 0; idx--) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            } else {\r\n                for (let l = fromLine; l < lines.length; l++) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : 0;\r\n                    for (let idx = searchStart; idx <= line.length - Math.min(markerTrim.length, oppositeTrim.length); idx++) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            }\r\n            return { type: null, pos: null };\r\n        }\r\n        let isComment = false;\r\n        let commentStartPos: { line: number, ch: number } | null = null;\r\n        let commentEndPos: { line: number, ch: number } | null = null;\r\n        const allLines = editor.getValue().split('\\n');\r\n        if (markerStart && markerEnd) {\r\n            let beforeType, afterType;\r\n            if (selection) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            } else {\r\n                const before = scanForFirst(allLines, cursor.line, cursor.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, cursor.line, cursor.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            }\r\n            if (beforeType === 'marker' && afterType === 'marker') {\r\n                isComment = true;\r\n            } else if (beforeType === 'opposite' && afterType === 'opposite') {\r\n                isComment = false;\r\n            } else {\r\n                isComment = false;\r\n            }\r\n        }\r\n        logDev('comment:', isComment, {\r\n            start: commentStartPos ? { line: commentStartPos.line + 1, ch: commentStartPos.ch + 1 } : null,\r\n            end: commentEndPos ? { line: commentEndPos.line + 1, ch: commentEndPos.ch + 1 } : null\r\n        });\r\n\r\n        if (selection && markerStart && markerEnd) {\r\n            const lineText = editor.getLine(from.line);\r\n            const selectionText = selection;\r\n            let foundStart = false, foundEnd = false;\r\n            let startIdx = selectionText.indexOf(markerStart);\r\n            let endIdx = selectionText.indexOf(markerEnd);\r\n            function containsPartOfMarker(sel: string, marker: string): boolean {\r\n                if (!marker) return false;\r\n                for (let i = 1; i <= marker.length; i++) {\r\n                    if (sel.includes(marker.slice(0, i)) || sel.includes(marker.slice(-i))) return true;\r\n                }\r\n                return false;\r\n            }\r\n            if (!foundStart && containsPartOfMarker(selectionText, markerStart)) {\r\n                const left = lineText.slice(Math.max(0, from.ch - markerStart.length), from.ch + selectionText.length);\r\n                if (left.includes(markerStart)) {\r\n                    foundStart = true;\r\n                    startIdx = left.indexOf(markerStart) - (from.ch - Math.max(0, from.ch - markerStart.length));\r\n                }\r\n            }\r\n            if (!foundEnd && containsPartOfMarker(selectionText, markerEnd)) {\r\n                const right = lineText.slice(from.ch, Math.min(lineText.length, to.ch + markerEnd.length));\r\n                if (right.includes(markerEnd)) {\r\n                    foundEnd = true;\r\n                    endIdx = right.indexOf(markerEnd);\r\n                }\r\n            }\r\n            if (selectionText.includes(markerStart)) {\r\n                foundStart = true;\r\n                startIdx = selectionText.indexOf(markerStart);\r\n            }\r\n            if (selectionText.includes(markerEnd)) {\r\n                foundEnd = true;\r\n                endIdx = selectionText.indexOf(markerEnd);\r\n            }\r\n            if (markerStart === markerEnd && markerStart.length > 0 && (foundStart || foundEnd)) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, '', 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, '', 'forward');\r\n                if (before.type === 'marker') commentStartPos = before.pos;\r\n                if (after.type === 'marker') commentEndPos = after.pos;\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            } else if (foundStart && !foundEnd) {\r\n                let searchLine = from.line;\r\n                let searchCh = lineText.indexOf(markerStart, from.ch);\r\n                if (searchCh === -1) searchCh = from.ch;\r\n                let found = false;\r\n                for (let l = searchLine; l < allLines.length; l++) {\r\n                    let line = allLines[l];\r\n                    let start = (l === searchLine) ? searchCh + markerStart.length : 0;\r\n                    for (let idx = start; idx <= line.length - markerEnd.length; idx++) {\r\n                        if (line.substr(idx, markerEnd.length) === markerEnd) {\r\n                            commentStartPos = { line: searchLine, ch: searchCh };\r\n                            commentEndPos = { line: l, ch: idx };\r\n                            isComment = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                        if (line.substr(idx, markerStart.length) === markerStart && (l !== searchLine || idx !== searchCh)) {\r\n                            logDev('Stopped search for end marker: found another start marker first', { from: { line: searchLine, ch: searchCh }, at: { line: l, ch: idx } });\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (found) break;\r\n                }\r\n            } else if (foundEnd && !foundStart) {\r\n                let searchLine = to.line;\r\n                let searchCh = lineText.indexOf(markerEnd, from.ch);\r\n                if (searchCh === -1) searchCh = to.ch;\r\n                let found = false;\r\n                for (let l = searchLine; l >= 0; l--) {\r\n                    let line = allLines[l];\r\n                    let end = (l === searchLine) ? searchCh - 1 : line.length - 1;\r\n                    for (let idx = end; idx >= 0; idx--) {\r\n                        if (line.substr(idx, markerStart.length) === markerStart) {\r\n                            commentStartPos = { line: l, ch: idx };\r\n                            commentEndPos = { line: searchLine, ch: searchCh };\r\n                            isComment = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                        if (line.substr(idx, markerEnd.length) === markerEnd && (l !== searchLine || idx !== searchCh)) {\r\n                            logDev('Stopped search for start marker: found another end marker first', { from: { line: searchLine, ch: searchCh }, at: { line: l, ch: idx } });\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (found) break;\r\n                }\r\n            }\r\n            const atStartBoundary = from.ch <= markerStart.length && lineText.slice(0, markerStart.length).startsWith(markerStart);\r\n            const atEndBoundary = to.ch >= lineText.length - markerEnd.length && lineText.slice(-markerEnd.length).endsWith(markerEnd);\r\n            if (!atStartBoundary && !atEndBoundary) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (selection && markerStart && markerEnd) {\r\n            const lineText = editor.getLine(from.line);\r\n            const selectionText = selection;\r\n            let foundStart = false, foundEnd = false;\r\n            let startIdx = selectionText.indexOf(markerStart);\r\n            let endIdx = selectionText.indexOf(markerEnd);\r\n            function containsPartOfMarker(sel: string, marker: string): boolean {\r\n                if (!marker) return false;\r\n                for (let i = 1; i <= marker.length; i++) {\r\n                    if (sel.includes(marker.slice(0, i)) || sel.includes(marker.slice(-i))) return true;\r\n                }\r\n                return false;\r\n            }\r\n            if (!foundStart && containsPartOfMarker(selectionText, markerStart)) {\r\n                const left = lineText.slice(Math.max(0, from.ch - markerStart.length), from.ch + selectionText.length);\r\n                if (left.includes(markerStart)) {\r\n                    foundStart = true;\r\n                    startIdx = left.indexOf(markerStart) - (from.ch - Math.max(0, from.ch - markerStart.length));\r\n                }\r\n            }\r\n            if (!foundEnd && containsPartOfMarker(selectionText, markerEnd)) {\r\n                const right = lineText.slice(from.ch, Math.min(lineText.length, to.ch + markerEnd.length));\r\n                if (right.includes(markerEnd)) {\r\n                    foundEnd = true;\r\n                    endIdx = right.indexOf(markerEnd);\r\n                }\r\n            }\r\n            if (selectionText.includes(markerStart)) {\r\n                foundStart = true;\r\n                startIdx = selectionText.indexOf(markerStart);\r\n            }\r\n            if (selectionText.includes(markerEnd)) {\r\n                foundEnd = true;\r\n                endIdx = selectionText.indexOf(markerEnd);\r\n            }\r\n            if (markerStart === markerEnd && markerStart.length > 0 && (foundStart || foundEnd)) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, '', 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, '', 'forward');\r\n                if (before.type === 'marker') commentStartPos = before.pos;\r\n                if (after.type === 'marker') commentEndPos = after.pos;\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            } else if (foundStart) {\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, markerStart, 'forward');\r\n                if (after.type === 'marker') commentEndPos = after.pos;\r\n                const startLineIdx = from.line;\r\n                const startChIdx = lineText.indexOf(markerStart, from.ch);\r\n                if (startChIdx !== -1) commentStartPos = { line: startLineIdx, ch: startChIdx };\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            } else if (foundEnd) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, markerEnd, 'back');\r\n                if (before.type === 'marker') commentStartPos = before.pos;\r\n                const endLineIdx = to.line;\r\n                const endChIdx = lineText.indexOf(markerEnd, from.ch);\r\n                if (endChIdx !== -1) commentEndPos = { line: endLineIdx, ch: endChIdx };\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            }\r\n        }\r\n\r\n        if (isComment && commentStartPos && commentEndPos) {\r\n            let startLine = allLines[commentStartPos.line];\r\n            const startMarkerWithSpace = markerStart + ' ';\r\n            allLines[commentStartPos.line] = startLine.slice(0, commentStartPos.ch) + startLine.slice(commentStartPos.ch + startMarkerWithSpace.length);\r\n            let endLineIdx = commentEndPos.line;\r\n            let endChIdx = commentEndPos.ch;\r\n            if (commentStartPos.line === commentEndPos.line) {\r\n                endChIdx -= startMarkerWithSpace.length;\r\n                let updatedLine = allLines[endLineIdx];\r\n                const endMarkerWithSpace = ' ' + markerEnd;\r\n                endChIdx = updatedLine.indexOf(endMarkerWithSpace, endChIdx);\r\n                if (endChIdx === -1) {\r\n                    endChIdx = updatedLine.indexOf(markerEnd, endChIdx);\r\n                    if (endChIdx > 0 && updatedLine[endChIdx - 1] === ' ') {\r\n                        endChIdx = endChIdx - 1;\r\n                    }\r\n                }\r\n                if (endChIdx === -1) {\r\n                    return;\r\n                }\r\n                allLines[endLineIdx] = updatedLine.slice(0, endChIdx) + updatedLine.slice(endChIdx + endMarkerWithSpace.length);\r\n            } else {\r\n                let endLine = allLines[endLineIdx];\r\n                const endMarkerWithSpace = ' ' + markerEnd;\r\n                allLines[endLineIdx] = endLine.slice(0, endChIdx) + endLine.slice(endChIdx + endMarkerWithSpace.length);\r\n            }\r\n            const fromLine = Math.min(commentStartPos.line, commentEndPos.line);\r\n            const toLine = Math.max(commentStartPos.line, commentEndPos.line);\r\n            const newText = allLines.slice(fromLine, toLine + 1).join('\\n');\r\n            editor.replaceRange(newText, { line: fromLine, ch: 0 }, { line: toLine, ch: editor.getLine(toLine).length });\r\n            let newCursorLine = from.line;\r\n            let newCursorCh = from.ch - startMarkerWithSpace.length;\r\n            if (newCursorCh < 0) newCursorCh = 0;\r\n            const lastLine = allLines.length - 1;\r\n            if (newCursorLine > lastLine) newCursorLine = lastLine;\r\n            let lineLen = allLines[newCursorLine]?.length ?? 0;\r\n            if (newCursorCh > lineLen) newCursorCh = lineLen;\r\n            let clamped = clampCursorPos({ line: newCursorLine, ch: newCursorCh });\r\n            editor.setCursor(clamped);\r\n            return;\r\n        }\r\n\r\n        let useWord = false;\r\n        wordBounds = getWordBounds(line, cursor.ch);\r\n        if (selection) {\r\n            useWord = false;\r\n        } else if (wordBounds) {\r\n            if (cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                useWord = true;\r\n            } else if (this.settings.wordOnlyMode && (cursor.ch === wordBounds.start || cursor.ch === wordBounds.end)) {\r\n                useWord = true;\r\n            } else {\r\n                useWord = false;\r\n            }\r\n        }\r\n        logDev('Mode:', selection ? 'selection' : useWord ? 'word' : 'insert', { selection, wordBounds, useWord });\r\n        if (selection) {\r\n            text = selection;\r\n        } else if (useWord && wordBounds) {\r\n            text = line.slice(wordBounds.start, wordBounds.end);\r\n            from = { line: cursor.line, ch: wordBounds.start };\r\n            to = { line: cursor.line, ch: wordBounds.end };\r\n        } else {\r\n            text = '';\r\n            from = { line: cursor.line, ch: cursor.ch };\r\n            to = { line: cursor.line, ch: cursor.ch };\r\n        }\r\n        let removalUsedStart = markerStart;\r\n        let removalUsedEnd = markerEnd;\r\n        let removalInside = false;\r\n        let removalCheckText = text;\r\n        if (selection) {\r\n            if (removalUsedStart && removalUsedEnd && selection.startsWith(removalUsedStart) && selection.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = selection;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && selection.startsWith(style.start) && selection.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = selection;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside) {\r\n                const lineStart = editor.getLine(from.line);\r\n                const lineEnd = editor.getLine(to.line);\r\n                if (removalUsedStart && removalUsedEnd && lineStart.startsWith(removalUsedStart) && lineEnd.endsWith(removalUsedEnd)) {\r\n                    removalInside = true;\r\n                    removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                } else {\r\n                    for (const style of defaultStyles) {\r\n                        if (style.start && style.end && lineStart.startsWith(style.start) && lineEnd.endsWith(style.end)) {\r\n                            removalUsedStart = style.start;\r\n                            removalUsedEnd = style.end;\r\n                            removalInside = true;\r\n                            removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (useWord && wordBounds) {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside && removalUsedStart && removalUsedEnd && text.startsWith(removalUsedStart) && text.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = text;\r\n            } else if (!removalInside) {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && text.startsWith(style.start) && text.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = text;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function removeNearestMarkersFromWordOrSelection(text: string, start: string, end: string, selectionStart: number, selectionEnd: number): { result: string, newStart: number, newEnd: number } {\r\n            return { result: text, newStart: selectionStart, newEnd: selectionEnd };\r\n        }\r\n        if (removalInside) {\r\n            if (selection && removalUsedStart && removalCheckText === removalUsedStart) {\r\n                const lineText = editor.getLine(from.line);\r\n                const startIdx = lineText.indexOf(removalUsedStart);\r\n                const endIdx = removalUsedEnd ? lineText.indexOf(removalUsedEnd, startIdx + removalUsedStart.length) : -1;\r\n                if (endIdx !== -1) {\r\n                    const between = lineText.slice(startIdx + removalUsedStart.length, endIdx);\r\n                    if (/^\\s*$/.test(between)) {\r\n                        logDev('Deleting end marker after deleting start marker', { line: from.line, startIdx, endIdx, removalUsedStart, removalUsedEnd });\r\n                        const before = lineText.slice(0, startIdx);\r\n                        const after = lineText.slice(endIdx + removalUsedEnd.length);\r\n                        editor.setLine(from.line, before + after);\r\n                        editor.setCursor({ line: from.line, ch: startIdx });\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        let usedStart = markerStart;\r\n        let usedEnd = markerEnd;\r\n        let inside = false;\r\n        let checkText = text;\r\n        if (selection) {\r\n            checkText = text;\r\n        } else if (useWord && wordBounds) {\r\n            checkText = line.slice(wordBounds.start, wordBounds.end);\r\n        } else {\r\n            checkText = text;\r\n        }\r\n        if (usedStart && isTextCommentedExact(checkText, usedStart, usedEnd)) {\r\n            inside = true;\r\n        } else {\r\n            for (const style of defaultStyles) {\r\n                if (style.start && isTextCommentedExact(checkText, style.start, style.end)) {\r\n                    usedStart = style.start;\r\n                    usedEnd = style.end;\r\n                    inside = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        function buildCommented(text: string) {\r\n            return markerStart + ' ' + text + ' ' + markerEnd;\r\n        }\r\n        function stripCommented(str: string) {\r\n            const start = markerStart + ' ';\r\n            const end = ' ' + markerEnd;\r\n            if (str.startsWith(start) && str.endsWith(end)) {\r\n                return str.slice(start.length, str.length - end.length);\r\n            }\r\n            if (str.startsWith(markerStart) && str.endsWith(markerEnd)) {\r\n                return str.slice(markerStart.length, str.length - markerEnd.length).trim();\r\n            }\r\n            return null;\r\n        }\r\n        let uncommented = null;\r\n        if (selection) {\r\n            uncommented = stripCommented(text);\r\n            if (uncommented !== null) inside = true;\r\n        } else if (useWord && wordBounds) {\r\n            const wordText = line.slice(wordBounds.start, wordBounds.end);\r\n            uncommented = stripCommented(wordText);\r\n            if (uncommented !== null) inside = true;\r\n        } else {\r\n            uncommented = stripCommented(text);\r\n            if (uncommented !== null) inside = true;\r\n        }\r\n        if (inside) {\r\n            const safeUncommented = uncommented !== null ? uncommented : text;\r\n            if (selection) {\r\n                editor.replaceSelection(safeUncommented);\r\n                const selFrom = clampCursorPos(from);\r\n                const selTo = clampCursorPos({ line: to.line, ch: from.ch + safeUncommented.length });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(safeUncommented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = wordBounds.start + safeUncommented.length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                editor.replaceRange(safeUncommented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch });\r\n                editor.setCursor(clamped);\r\n            }\r\n        } else {\r\n            let trimmedText = text.trim();\r\n            let commented: string;\r\n            if (!selection && !trimmedText) {\r\n                commented = markerStart + '  ' + markerEnd;\r\n            } else {\r\n                commented = buildCommented(trimmedText);\r\n            }\r\n            if (!selection && !trimmedText) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const cursorPos = cursor.ch + (markerStart + ' ').length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursorPos });\r\n                editor.setCursor(clamped);\r\n            } else if (selection) {\r\n                editor.replaceSelection(commented);\r\n                const startOffset = (markerStart + ' ').length;\r\n                const selFrom = clampCursorPos({ line: from.line, ch: from.ch + startOffset });\r\n                const selTo = clampCursorPos({ line: to.line, ch: from.ch + startOffset + trimmedText.length });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = wordBounds.start + (markerStart + ' ').length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch + (markerStart + ' ').length });\r\n                editor.setCursor(clamped);\r\n            }\r\n        }\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "mbAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,aAAAE,IAAA,eAAAC,GAAAH,IAQA,IAAAI,GAA+B,oBCaxB,IAAMC,GAA0C,CACnD,SAAU,iBACV,aAAc,GACd,kBAAmB,CAAC,CACxB,ECjBA,IAAAC,EAA+C,oBAGlCC,EAAN,cAAsC,kBAAiB,CAG1D,YAAYC,EAAUC,EAA6B,CAC/C,MAAMD,EAAKC,CAAM,EACjB,KAAK,OAASA,CAClB,CAEA,SAAgB,CACZ,GAAM,CAAE,YAAAC,CAAY,EAAI,KACxBA,EAAY,MAAM,EAElB,IAAI,UAAQA,CAAW,EAClB,QAAQ,gBAAgB,EACxB,QAAQ,iGAAiG,EACzG,QAAQC,GACLA,EACK,SAAS,KAAK,OAAO,SAAS,QAAQ,EACtC,SAAS,MAAOC,GAAU,CACvB,KAAK,OAAO,SAAS,SAAWA,GAAS,iBACzC,MAAM,KAAK,OAAO,aAAa,CACnC,CAAC,CACT,EAEJ,IAAI,UAAQF,CAAW,EAClB,QAAQ,uBAAuB,EAC/B,QAAQ,gIAAgI,EACxI,UAAUG,GACPA,EACK,SAAS,CAAC,CAAC,KAAK,OAAO,SAAS,YAAY,EAC5C,SAAS,MAAOD,GAAU,CACvB,KAAK,OAAO,SAAS,aAAeA,EACpC,MAAM,KAAK,OAAO,aAAa,CACnC,CAAC,CACT,EAGJF,EAAY,SAAS,KAAM,CAAE,KAAM,wBAAyB,CAAC,GACnC,KAAK,OAAO,SAAS,mBAAqB,CAAC,GACnD,QAAQ,CAACI,EAAQC,IAAQ,CACvC,IAAMC,EAAU,IAAI,UAAQN,CAAW,EAClC,QAAQ,cAAcK,EAAM,CAAC,EAAE,EAE/B,UAAUF,GAAUA,EAChB,SAAS,CAAC,CAACC,EAAO,eAAe,EACjC,SAAS,MAAOF,GAAU,CACnB,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkBG,CAAG,EAAE,gBAAkBH,EAC9D,MAAM,KAAK,OAAO,aAAa,EAC/B,KAAK,OAAO,uBAAuB,EAAI,EACvC,KAAK,QAAQ,EAErB,CAAC,CACL,EACC,QAAQD,GAAQA,EACZ,eAAe,cAAc,EAC7B,SAASG,EAAO,KAAK,EACrB,SAAS,MAAOF,GAAU,CACnB,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkBG,CAAG,EAAE,MAAQH,EACpD,MAAM,KAAK,OAAO,aAAa,EAGvC,CAAC,CACL,EACC,QAAQD,GAAQA,EACZ,eAAe,YAAY,EAC3B,SAASG,EAAO,GAAG,EACnB,SAAS,MAAOF,GAAU,CACnB,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkBG,CAAG,EAAE,IAAMH,EAClD,MAAM,KAAK,OAAO,aAAa,EAGvC,CAAC,CACL,EACC,eAAeK,GAAOA,EAClB,QAAQ,OAAO,EACf,WAAW,mBAAmB,EAC9B,QAAQ,SAAY,CACb,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkB,OAAOF,EAAK,CAAC,EACpD,MAAM,KAAK,OAAO,aAAa,EAC/B,KAAK,QAAQ,EAErB,CAAC,CACL,CACR,CAAC,EACD,IAAI,UAAQL,CAAW,EAClB,UAAUO,GAAOA,EACb,cAAc,gBAAgB,EAC9B,OAAO,EACP,QAAQ,SAAY,CACZ,KAAK,OAAO,SAAS,oBAAmB,KAAK,OAAO,SAAS,kBAAoB,CAAC,GACvF,KAAK,OAAO,SAAS,kBAAkB,KAAK,CAAE,MAAO,GAAI,IAAK,GAAI,gBAAiB,EAAM,CAAC,EAC1F,MAAM,KAAK,OAAO,aAAa,EAC/B,KAAK,QAAQ,CACjB,CAAC,CACL,CACR,CACJ,EF5FA,SAASC,KAAUC,EAAa,CAGxB,QAAQ,IAAI,sBAAuB,GAAGA,CAAI,CAElD,CAGA,IAAMC,EAAgB,CAClB,CAAE,MAAO,KAAM,IAAK,IAAK,EACzB,CAAE,MAAO,OAAQ,IAAK,KAAM,EAC5B,CAAE,MAAO,KAAM,IAAK,EAAG,CAC3B,EAMqBC,EAArB,cAAiD,SAAO,CAAxD,kCAKI,KAAQ,kBAA8B,CAAC,EACvC,KAAQ,cAAyB,GAKjC,MAAM,QAAS,CACXH,EAAO,mBAAmB,EAC1B,MAAM,KAAK,aAAa,EACxB,KAAK,cAAc,IAAII,EAAwB,KAAK,IAAK,IAAI,CAAC,EAG9D,KAAK,WAAW,CACZ,GAAI,yBACJ,KAAM,yBACN,SAAU,IAAM,KAAK,uBAAuB,EAAI,CACpD,CAAC,EAED,KAAK,uBAAuB,CAEhC,CAKA,uBAAuBC,EAAQ,GAAO,CAC9BA,GAAS,KAAK,oBACd,KAAK,kBAAoB,CAAC,GAE9B,KAAK,kBAAoB,CAAC,EAG1B,IAAIC,EAAe,KAAK,SAAS,UAAY,iBACvCC,EAAcD,EAAa,QAAQ,UAAU,EAC/CE,EAAS,KACTC,EAAQ,KACRF,IAAgB,KAChBC,EAASF,EAAa,MAAM,EAAGC,CAAW,EAAE,KAAK,GAAK,KACtDE,EAAQH,EAAa,MAAMC,EAAc,CAAiB,EAAE,KAAK,GAAK,MAE1E,IAAMG,EAAS,0BACf,KAAK,WAAW,CACZ,GAAIA,EACJ,KAAM,oBAAoBF,CAAM,IAAIC,CAAK,IACzC,eAAiBE,GAAmB,KAAK,cAAcA,CAAM,CACjE,CAAC,EACD,KAAK,kBAAkB,KAAKD,CAAM,EAG9B,MAAM,QAAQ,KAAK,SAAS,iBAAiB,GAC7C,KAAK,SAAS,kBAAkB,QAAQ,CAACE,EAAQC,IAAM,CACnD,GAAID,GAAUA,EAAO,gBAAiB,CAClC,IAAME,EAAK,6BAA6BD,EAAI,CAAC,GAC7C,KAAK,WAAW,CACZ,GAAAC,EACA,MAAO,IAAM,CACT,IAAMC,EAAQH,EAAO,OAAO,KAAK,GAAK,KAChCI,EAAMJ,EAAO,KAAK,KAAK,GAAK,KAClC,MAAO,iBAAiBC,EAAI,CAAC,MAAME,CAAK,IAAIC,CAAG,GACnD,GAAG,EACH,cAAe,CAACC,EAAmBN,KAC3B,CAACM,GAAYN,GAAQ,KAAK,cAAcA,EAAQC,CAAM,EACnD,GAEf,CAAC,EACD,KAAK,kBAAkB,KAAKE,CAAE,CAClC,CACJ,CAAC,EAELd,EAAO,8BAA+B,KAAK,iBAAiB,CAChE,CAKA,MAAM,cAAe,CACjB,KAAK,SAAW,OAAO,OAAO,CAAC,EAAGkB,GAAkB,MAAM,KAAK,SAAS,CAAC,EACzElB,EAAO,mBAAoB,KAAK,QAAQ,CAC5C,CAKA,MAAM,cAAe,CACjB,MAAM,KAAK,SAAS,KAAK,QAAQ,EACjCA,EAAO,kBAAmB,KAAK,QAAQ,CAC3C,CAMA,MAAM,cAAe,CAEjB,MAAM,KAAK,IAAI,QAAQ,cAAc,KAAK,SAAS,EAAE,EAErD,MAAM,KAAK,IAAI,QAAQ,aAAa,KAAK,SAAS,EAAE,EACpDA,EAAO,iBAAiB,CAC5B,CAKA,cAAcW,EAAgB,CAC1B,IAAIQ,EAAW,KAAK,SAAS,SACzBZ,EAAcY,EAAS,QAAQ,UAAU,EAC7C,GAAIZ,IAAgB,GAAI,CACpBI,EAAO,iBAAiBQ,CAAQ,EAChCnB,EAAO,2CAA2C,EAClD,MACJ,CACA,IAAIQ,EAASW,EAAS,MAAM,EAAGZ,CAAW,EAAE,KAAK,EAC7CE,EAAQU,EAAS,MAAMZ,EAAc,CAAiB,EAAE,KAAK,EAC3Da,EAAc,GAAGZ,CAAM,IAAIC,CAAK,GAAG,QAAQ,OAAQ,GAAG,EAAE,KAAK,EAC7DY,EAAOV,EAAO,UAAU,EAC9BA,EAAO,iBAAiB,GAAGH,CAAM,KAAKC,CAAK,GAAG,QAAQ,OAAQ,GAAG,EAAE,QAAQ,IAAK,YAAY,CAAC,EAC7F,IAAMa,EAAQd,EAAO,MAAM;AAAA,CAAI,EACzBe,EAAmBD,EAAM,OAAS,EAClCE,EAAiBF,EAAMA,EAAM,OAAS,CAAC,EAAE,OAAS,EACxDX,EAAO,UAAU,CACb,KAAMU,EAAK,KAAOE,EAClB,IAAKA,EAAmB,EAAIF,EAAK,IAAMG,CAC3C,CAAC,EACDxB,EAAO,4BAA4B,CACvC,CAQA,cAAcW,EAAgBc,EAA4C,CACtEzB,EAAO,uBAAwB,CAAE,UAAWW,EAAO,aAAa,EAAG,OAAQA,EAAO,UAAU,EAAG,UAAAc,CAAU,CAAC,EAE1G,SAASC,EAAeC,EAAiE,CACrF,IAAMC,EAAWjB,EAAO,SAAS,EAAE,MAAM;AAAA,CAAI,EACzCkB,EAAO,KAAK,IAAI,EAAG,KAAK,IAAIF,EAAI,KAAMC,EAAS,OAAS,CAAC,CAAC,EAC1DE,EAAK,KAAK,IAAI,EAAG,KAAK,IAAIH,EAAI,GAAIC,EAASC,CAAI,GAAG,QAAU,CAAC,CAAC,EAClE,MAAO,CAAE,KAAAA,EAAM,GAAAC,CAAG,CACtB,CACA,IAAIC,EAAqBC,EACrBC,EAA+BC,EACnC,GAAIT,EACAM,EAAcN,EAAU,MAAM,KAAK,EACnCO,EAAYP,EAAU,IAAI,KAAK,EAC/BQ,EAAwBR,EAAU,MAAM,SAAS,GAAG,EAAGA,EAAU,MAAQA,EAAU,MAAQ,IAC3FS,EAAsBT,EAAU,IAAI,WAAW,GAAG,EAAGA,EAAU,IAAM,IAAMA,EAAU,QAClF,CACH,IAAMN,EAAW,KAAK,SAAS,SACzBZ,EAAcY,EAAS,QAAQ,UAAU,EAC3CX,EAASW,EACTV,EAAQ,GACRF,IAAgB,KAChBC,EAASW,EAAS,MAAM,EAAGZ,CAAW,EACtCE,EAAQU,EAAS,MAAMZ,EAAc,CAAiB,GAE1DwB,EAAcvB,EAAO,KAAK,EAC1BwB,EAAYvB,EAAM,KAAK,EACvBwB,EAAwBF,GAAeA,GAAe,CAACA,EAAY,SAAS,GAAG,EAAG,IAAM,IACxFG,GAAuBF,GAAa,CAACA,EAAU,WAAW,GAAG,EAAG,IAAM,IAAMA,CAChF,CACA,IAAMG,EAAYxB,EAAO,aAAa,EAChCyB,EAASzB,EAAO,UAAU,EAC5B0B,EACAhB,EAAOV,EAAO,UAAU,MAAM,EAC9B2B,EAAK3B,EAAO,UAAU,IAAI,EAC1B4B,EAAoD,KACpDV,EAAOlB,EAAO,QAAQyB,EAAO,IAAI,EACrC,SAASI,GAAcX,EAAcC,EAAmD,CACpF,IAAMW,EAAQ,mBACVC,EACJ,MAAQA,EAAQD,EAAM,KAAKZ,CAAI,KAAO,MAClC,GAAIC,GAAMY,EAAM,OAASZ,GAAMY,EAAM,MAAQA,EAAM,CAAC,EAAE,OAClD,MAAO,CAAE,MAAOA,EAAM,MAAO,IAAKA,EAAM,MAAQA,EAAM,CAAC,EAAE,MAAO,EAGxE,OAAO,IACX,CACA,SAASC,GAAqBC,EAAa7B,EAAeC,EAAa,CACnE,OAAKD,EACDC,EACO4B,EAAI,WAAW7B,CAAK,GAAK6B,EAAI,SAAS5B,CAAG,EAEzC4B,EAAI,WAAW7B,CAAK,EAJZ,EAMvB,CACA,SAAS8B,EAAavB,EAAiBwB,EAAkBC,EAAgBnC,EAAgBoC,EAAkBC,EAAiH,CACxN,IAAMC,EAAatC,EAAO,KAAK,EACzBuC,EAAeH,EAAS,KAAK,EACnC,GAAIC,IAAc,OACd,QAASG,EAAIN,EAAUM,GAAK,EAAGA,IAAK,CAChC,IAAIvB,EAAOP,EAAM8B,CAAC,EACdC,EAAcD,IAAMN,EAAWC,EAASlB,EAAK,OACjD,QAASyB,EAAMD,EAAc,EAAGC,GAAO,EAAGA,IAAO,CAC7C,GAAIzB,EAAK,OAAOyB,EAAKJ,EAAW,MAAM,IAAMA,EAAY,MAAO,CAAE,KAAM,SAAU,IAAK,CAAE,KAAME,EAAG,GAAIE,CAAI,CAAE,EAC3G,GAAIzB,EAAK,OAAOyB,EAAKH,EAAa,MAAM,IAAMA,EAAc,MAAO,CAAE,KAAM,WAAY,IAAK,CAAE,KAAMC,EAAG,GAAIE,CAAI,CAAE,CACrH,CACJ,KAEA,SAASF,EAAIN,EAAUM,EAAI9B,EAAM,OAAQ8B,IAAK,CAC1C,IAAIvB,EAAOP,EAAM8B,CAAC,EACdC,EAAcD,IAAMN,EAAWC,EAAS,EAC5C,QAASO,EAAMD,EAAaC,GAAOzB,EAAK,OAAS,KAAK,IAAIqB,EAAW,OAAQC,EAAa,MAAM,EAAGG,IAAO,CACtG,GAAIzB,EAAK,OAAOyB,EAAKJ,EAAW,MAAM,IAAMA,EAAY,MAAO,CAAE,KAAM,SAAU,IAAK,CAAE,KAAME,EAAG,GAAIE,CAAI,CAAE,EAC3G,GAAIzB,EAAK,OAAOyB,EAAKH,EAAa,MAAM,IAAMA,EAAc,MAAO,CAAE,KAAM,WAAY,IAAK,CAAE,KAAMC,EAAG,GAAIE,CAAI,CAAE,CACrH,CACJ,CAEJ,MAAO,CAAE,KAAM,KAAM,IAAK,IAAK,CACnC,CACA,IAAIC,EAAY,GACZC,EAAuD,KACvDC,EAAqD,KACnD7B,EAAWjB,EAAO,SAAS,EAAE,MAAM;AAAA,CAAI,EAC7C,GAAIoB,GAAeC,EAAW,CAC1B,IAAI0B,EAAYC,EAChB,GAAIxB,EAAW,CACX,IAAM3B,EAASqC,EAAajB,EAAUP,EAAK,KAAMA,EAAK,GAAIU,EAAaC,EAAW,MAAM,EAClFvB,EAAQoC,EAAajB,EAAUU,EAAG,KAAMA,EAAG,GAAIN,EAAWD,EAAa,SAAS,EACtF2B,EAAalD,EAAO,KACpBmD,EAAYlD,EAAM,KACdiD,IAAe,WAAUF,EAAkBhD,EAAO,KAClDmD,IAAc,WAAUF,EAAgBhD,EAAM,IACtD,KAAO,CACH,IAAMD,EAASqC,EAAajB,EAAUQ,EAAO,KAAMA,EAAO,GAAIL,EAAaC,EAAW,MAAM,EACtFvB,EAAQoC,EAAajB,EAAUQ,EAAO,KAAMA,EAAO,GAAIJ,EAAWD,EAAa,SAAS,EAC9F2B,EAAalD,EAAO,KACpBmD,EAAYlD,EAAM,KACdiD,IAAe,WAAUF,EAAkBhD,EAAO,KAClDmD,IAAc,WAAUF,EAAgBhD,EAAM,IACtD,CACIiD,IAAe,UAAYC,IAAc,SACzCJ,EAAY,GAEZA,EAAY,EAIpB,CAMA,GALAvD,EAAO,WAAYuD,EAAW,CAC1B,MAAOC,EAAkB,CAAE,KAAMA,EAAgB,KAAO,EAAG,GAAIA,EAAgB,GAAK,CAAE,EAAI,KAC1F,IAAKC,EAAgB,CAAE,KAAMA,EAAc,KAAO,EAAG,GAAIA,EAAc,GAAK,CAAE,EAAI,IACtF,CAAC,EAEGtB,GAAaJ,GAAeC,EAAW,CAMvC,IAAS4B,EAAT,SAA8BC,EAAajD,EAAyB,CAChE,GAAI,CAACA,EAAQ,MAAO,GACpB,QAASC,EAAI,EAAGA,GAAKD,EAAO,OAAQC,IAChC,GAAIgD,EAAI,SAASjD,EAAO,MAAM,EAAGC,CAAC,CAAC,GAAKgD,EAAI,SAASjD,EAAO,MAAM,CAACC,CAAC,CAAC,EAAG,MAAO,GAEnF,MAAO,EACX,EANS,IAAA+C,KALT,IAAME,EAAWnD,EAAO,QAAQU,EAAK,IAAI,EACnC0C,EAAgB5B,EAClB6B,EAAa,GAAOC,EAAW,GAC/BC,EAAWH,EAAc,QAAQhC,CAAW,EAC5CoC,EAASJ,EAAc,QAAQ/B,CAAS,EAQ5C,GAAI,CAACgC,GAAcJ,EAAqBG,EAAehC,CAAW,EAAG,CACjE,IAAMqC,EAAON,EAAS,MAAM,KAAK,IAAI,EAAGzC,EAAK,GAAKU,EAAY,MAAM,EAAGV,EAAK,GAAK0C,EAAc,MAAM,EACjGK,EAAK,SAASrC,CAAW,IACzBiC,EAAa,GACbE,EAAWE,EAAK,QAAQrC,CAAW,GAAKV,EAAK,GAAK,KAAK,IAAI,EAAGA,EAAK,GAAKU,EAAY,MAAM,GAElG,CACA,GAAI,CAACkC,GAAYL,EAAqBG,EAAe/B,CAAS,EAAG,CAC7D,IAAMqC,EAAQP,EAAS,MAAMzC,EAAK,GAAI,KAAK,IAAIyC,EAAS,OAAQxB,EAAG,GAAKN,EAAU,MAAM,CAAC,EACrFqC,EAAM,SAASrC,CAAS,IACxBiC,EAAW,GACXE,EAASE,EAAM,QAAQrC,CAAS,EAExC,CASA,GARI+B,EAAc,SAAShC,CAAW,IAClCiC,EAAa,GACbE,EAAWH,EAAc,QAAQhC,CAAW,GAE5CgC,EAAc,SAAS/B,CAAS,IAChCiC,EAAW,GACXE,EAASJ,EAAc,QAAQ/B,CAAS,GAExCD,IAAgBC,GAAaD,EAAY,OAAS,IAAMiC,GAAcC,GAAW,CACjF,IAAMzD,EAASqC,EAAajB,EAAUP,EAAK,KAAMA,EAAK,GAAIU,EAAa,GAAI,MAAM,EAC3EtB,EAAQoC,EAAajB,EAAUU,EAAG,KAAMA,EAAG,GAAIN,EAAW,GAAI,SAAS,EACzExB,EAAO,OAAS,WAAUgD,EAAkBhD,EAAO,KACnDC,EAAM,OAAS,WAAUgD,EAAgBhD,EAAM,KAC/C+C,GAAmBC,IAAeF,EAAY,GACtD,SAAWS,GAAc,CAACC,EAAU,CAChC,IAAIK,EAAajD,EAAK,KAClBkD,EAAWT,EAAS,QAAQ/B,EAAaV,EAAK,EAAE,EAChDkD,IAAa,KAAIA,EAAWlD,EAAK,IACrC,IAAImD,EAAQ,GACZ,QAASpB,EAAIkB,EAAYlB,EAAIxB,EAAS,OAAQwB,IAAK,CAC/C,IAAIvB,EAAOD,EAASwB,CAAC,EACjBrC,EAASqC,IAAMkB,EAAcC,EAAWxC,EAAY,OAAS,EACjE,QAASuB,EAAMvC,EAAOuC,GAAOzB,EAAK,OAASG,EAAU,OAAQsB,IAAO,CAChE,GAAIzB,EAAK,OAAOyB,EAAKtB,EAAU,MAAM,IAAMA,EAAW,CAClDwB,EAAkB,CAAE,KAAMc,EAAY,GAAIC,CAAS,EACnDd,EAAgB,CAAE,KAAML,EAAG,GAAIE,CAAI,EACnCC,EAAY,GACZiB,EAAQ,GACR,KACJ,CACA,GAAI3C,EAAK,OAAOyB,EAAKvB,EAAY,MAAM,IAAMA,IAAgBqB,IAAMkB,GAAchB,IAAQiB,GAAW,CAChGvE,EAAO,kEAAmE,CAAE,KAAM,CAAE,KAAMsE,EAAY,GAAIC,CAAS,EAAG,GAAI,CAAE,KAAMnB,EAAG,GAAIE,CAAI,CAAE,CAAC,EAChJkB,EAAQ,GACR,KACJ,CACJ,CACA,GAAIA,EAAO,KACf,CACJ,SAAWP,GAAY,CAACD,EAAY,CAChC,IAAIM,EAAahC,EAAG,KAChBiC,EAAWT,EAAS,QAAQ9B,EAAWX,EAAK,EAAE,EAC9CkD,IAAa,KAAIA,EAAWjC,EAAG,IACnC,IAAIkC,EAAQ,GACZ,QAASpB,EAAIkB,EAAYlB,GAAK,EAAGA,IAAK,CAClC,IAAIvB,EAAOD,EAASwB,CAAC,EACjBpC,EAAOoC,IAAMkB,EAAcC,EAAW,EAAI1C,EAAK,OAAS,EAC5D,QAASyB,EAAMtC,EAAKsC,GAAO,EAAGA,IAAO,CACjC,GAAIzB,EAAK,OAAOyB,EAAKvB,EAAY,MAAM,IAAMA,EAAa,CACtDyB,EAAkB,CAAE,KAAMJ,EAAG,GAAIE,CAAI,EACrCG,EAAgB,CAAE,KAAMa,EAAY,GAAIC,CAAS,EACjDhB,EAAY,GACZiB,EAAQ,GACR,KACJ,CACA,GAAI3C,EAAK,OAAOyB,EAAKtB,EAAU,MAAM,IAAMA,IAAcoB,IAAMkB,GAAchB,IAAQiB,GAAW,CAC5FvE,EAAO,kEAAmE,CAAE,KAAM,CAAE,KAAMsE,EAAY,GAAIC,CAAS,EAAG,GAAI,CAAE,KAAMnB,EAAG,GAAIE,CAAI,CAAE,CAAC,EAChJkB,EAAQ,GACR,KACJ,CACJ,CACA,GAAIA,EAAO,KACf,CACJ,CACA,IAAMC,EAAkBpD,EAAK,IAAMU,EAAY,QAAU+B,EAAS,MAAM,EAAG/B,EAAY,MAAM,EAAE,WAAWA,CAAW,EAC/G2C,EAAgBpC,EAAG,IAAMwB,EAAS,OAAS9B,EAAU,QAAU8B,EAAS,MAAM,CAAC9B,EAAU,MAAM,EAAE,SAASA,CAAS,EACzH,GAAI,CAACyC,GAAmB,CAACC,EACrB,MAER,CAEA,GAAIvC,GAAaJ,GAAeC,EAAW,CAMvC,IAAS4B,EAAT,SAA8BC,EAAajD,EAAyB,CAChE,GAAI,CAACA,EAAQ,MAAO,GACpB,QAASC,EAAI,EAAGA,GAAKD,EAAO,OAAQC,IAChC,GAAIgD,EAAI,SAASjD,EAAO,MAAM,EAAGC,CAAC,CAAC,GAAKgD,EAAI,SAASjD,EAAO,MAAM,CAACC,CAAC,CAAC,EAAG,MAAO,GAEnF,MAAO,EACX,EANS,IAAA+C,KALT,IAAME,EAAWnD,EAAO,QAAQU,EAAK,IAAI,EACnC0C,EAAgB5B,EAClB6B,EAAa,GAAOC,EAAW,GAC/BC,EAAWH,EAAc,QAAQhC,CAAW,EAC5CoC,EAASJ,EAAc,QAAQ/B,CAAS,EAQ5C,GAAI,CAACgC,GAAcJ,EAAqBG,EAAehC,CAAW,EAAG,CACjE,IAAMqC,EAAON,EAAS,MAAM,KAAK,IAAI,EAAGzC,EAAK,GAAKU,EAAY,MAAM,EAAGV,EAAK,GAAK0C,EAAc,MAAM,EACjGK,EAAK,SAASrC,CAAW,IACzBiC,EAAa,GACbE,EAAWE,EAAK,QAAQrC,CAAW,GAAKV,EAAK,GAAK,KAAK,IAAI,EAAGA,EAAK,GAAKU,EAAY,MAAM,GAElG,CACA,GAAI,CAACkC,GAAYL,EAAqBG,EAAe/B,CAAS,EAAG,CAC7D,IAAMqC,EAAQP,EAAS,MAAMzC,EAAK,GAAI,KAAK,IAAIyC,EAAS,OAAQxB,EAAG,GAAKN,EAAU,MAAM,CAAC,EACrFqC,EAAM,SAASrC,CAAS,IACxBiC,EAAW,GACXE,EAASE,EAAM,QAAQrC,CAAS,EAExC,CASA,GARI+B,EAAc,SAAShC,CAAW,IAClCiC,EAAa,GACbE,EAAWH,EAAc,QAAQhC,CAAW,GAE5CgC,EAAc,SAAS/B,CAAS,IAChCiC,EAAW,GACXE,EAASJ,EAAc,QAAQ/B,CAAS,GAExCD,IAAgBC,GAAaD,EAAY,OAAS,IAAMiC,GAAcC,GAAW,CACjF,IAAMzD,EAASqC,EAAajB,EAAUP,EAAK,KAAMA,EAAK,GAAIU,EAAa,GAAI,MAAM,EAC3EtB,EAAQoC,EAAajB,EAAUU,EAAG,KAAMA,EAAG,GAAIN,EAAW,GAAI,SAAS,EACzExB,EAAO,OAAS,WAAUgD,EAAkBhD,EAAO,KACnDC,EAAM,OAAS,WAAUgD,EAAgBhD,EAAM,KAC/C+C,GAAmBC,IAAeF,EAAY,GACtD,SAAWS,EAAY,CACnB,IAAMvD,EAAQoC,EAAajB,EAAUU,EAAG,KAAMA,EAAG,GAAIN,EAAWD,EAAa,SAAS,EAClFtB,EAAM,OAAS,WAAUgD,EAAgBhD,EAAM,KACnD,IAAMkE,EAAetD,EAAK,KACpBuD,EAAad,EAAS,QAAQ/B,EAAaV,EAAK,EAAE,EACpDuD,IAAe,KAAIpB,EAAkB,CAAE,KAAMmB,EAAc,GAAIC,CAAW,GAC1EpB,GAAmBC,IAAeF,EAAY,GACtD,SAAWU,EAAU,CACjB,IAAMzD,EAASqC,EAAajB,EAAUP,EAAK,KAAMA,EAAK,GAAIU,EAAaC,EAAW,MAAM,EACpFxB,EAAO,OAAS,WAAUgD,EAAkBhD,EAAO,KACvD,IAAMqE,EAAavC,EAAG,KAChBwC,EAAWhB,EAAS,QAAQ9B,EAAWX,EAAK,EAAE,EAChDyD,IAAa,KAAIrB,EAAgB,CAAE,KAAMoB,EAAY,GAAIC,CAAS,GAClEtB,GAAmBC,IAAeF,EAAY,GACtD,CACJ,CAEA,GAAIA,GAAaC,GAAmBC,EAAe,CAC/C,IAAIsB,EAAYnD,EAAS4B,EAAgB,IAAI,EACvCwB,EAAuBjD,EAAc,IAC3CH,EAAS4B,EAAgB,IAAI,EAAIuB,EAAU,MAAM,EAAGvB,EAAgB,EAAE,EAAIuB,EAAU,MAAMvB,EAAgB,GAAKwB,EAAqB,MAAM,EAC1I,IAAIH,EAAapB,EAAc,KAC3BqB,EAAWrB,EAAc,GAC7B,GAAID,EAAgB,OAASC,EAAc,KAAM,CAC7CqB,GAAYE,EAAqB,OACjC,IAAIC,EAAcrD,EAASiD,CAAU,EAC/BK,EAAqB,IAAMlD,EAQjC,GAPA8C,EAAWG,EAAY,QAAQC,EAAoBJ,CAAQ,EACvDA,IAAa,KACbA,EAAWG,EAAY,QAAQjD,EAAW8C,CAAQ,EAC9CA,EAAW,GAAKG,EAAYH,EAAW,CAAC,IAAM,MAC9CA,EAAWA,EAAW,IAG1BA,IAAa,GACb,OAEJlD,EAASiD,CAAU,EAAII,EAAY,MAAM,EAAGH,CAAQ,EAAIG,EAAY,MAAMH,EAAWI,EAAmB,MAAM,CAClH,KAAO,CACH,IAAIC,EAAUvD,EAASiD,CAAU,EAC3BK,EAAqB,IAAMlD,EACjCJ,EAASiD,CAAU,EAAIM,EAAQ,MAAM,EAAGL,CAAQ,EAAIK,EAAQ,MAAML,EAAWI,EAAmB,MAAM,CAC1G,CACA,IAAMpC,EAAW,KAAK,IAAIU,EAAgB,KAAMC,EAAc,IAAI,EAC5D2B,EAAS,KAAK,IAAI5B,EAAgB,KAAMC,EAAc,IAAI,EAC1D4B,EAAUzD,EAAS,MAAMkB,EAAUsC,EAAS,CAAC,EAAE,KAAK;AAAA,CAAI,EAC9DzE,EAAO,aAAa0E,EAAS,CAAE,KAAMvC,EAAU,GAAI,CAAE,EAAG,CAAE,KAAMsC,EAAQ,GAAIzE,EAAO,QAAQyE,CAAM,EAAE,MAAO,CAAC,EAC3G,IAAIE,EAAgBjE,EAAK,KACrBkE,EAAclE,EAAK,GAAK2D,EAAqB,OAC7CO,EAAc,IAAGA,EAAc,GACnC,IAAMC,EAAW5D,EAAS,OAAS,EAC/B0D,EAAgBE,IAAUF,EAAgBE,GAC9C,IAAIC,EAAU7D,EAAS0D,CAAa,GAAG,QAAU,EAC7CC,EAAcE,IAASF,EAAcE,GACzC,IAAIC,EAAUhE,EAAe,CAAE,KAAM4D,EAAe,GAAIC,CAAY,CAAC,EACrE5E,EAAO,UAAU+E,CAAO,EACxB,MACJ,CAEA,IAAIC,EAAU,GACdpD,EAAaC,GAAcX,EAAMO,EAAO,EAAE,EACtCD,EACAwD,EAAU,GACHpD,IACHH,EAAO,GAAKG,EAAW,OAASH,EAAO,GAAKG,EAAW,KAEhD,KAAK,SAAS,eAAiBH,EAAO,KAAOG,EAAW,OAASH,EAAO,KAAOG,EAAW,KADjGoD,EAAU,GAIVA,EAAU,IAGlB3F,EAAO,QAASmC,EAAY,YAAcwD,EAAU,OAAS,SAAU,CAAE,UAAAxD,EAAW,WAAAI,EAAY,QAAAoD,CAAQ,CAAC,EACrGxD,EACAE,EAAOF,EACAwD,GAAWpD,GAClBF,EAAOR,EAAK,MAAMU,EAAW,MAAOA,EAAW,GAAG,EAClDlB,EAAO,CAAE,KAAMe,EAAO,KAAM,GAAIG,EAAW,KAAM,EACjDD,EAAK,CAAE,KAAMF,EAAO,KAAM,GAAIG,EAAW,GAAI,IAE7CF,EAAO,GACPhB,EAAO,CAAE,KAAMe,EAAO,KAAM,GAAIA,EAAO,EAAG,EAC1CE,EAAK,CAAE,KAAMF,EAAO,KAAM,GAAIA,EAAO,EAAG,GAE5C,IAAIwD,EAAmB7D,EACnB8D,EAAiB7D,EACjB8D,EAAgB,GAChBC,EAAmB1D,EACvB,GAAIF,EAAW,CACX,GAAIyD,GAAoBC,GAAkB1D,EAAU,WAAWyD,CAAgB,GAAKzD,EAAU,SAAS0D,CAAc,EACjHC,EAAgB,GAChBC,EAAmB5D,MAEnB,SAAW6D,KAAS9F,EAChB,GAAI8F,EAAM,OAASA,EAAM,KAAO7D,EAAU,WAAW6D,EAAM,KAAK,GAAK7D,EAAU,SAAS6D,EAAM,GAAG,EAAG,CAChGJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmB5D,EACnB,KACJ,CAGR,GAAI,CAAC2D,EAAe,CAChB,IAAMG,EAAYtF,EAAO,QAAQU,EAAK,IAAI,EACpC6E,EAAUvF,EAAO,QAAQ2B,EAAG,IAAI,EACtC,GAAIsD,GAAoBC,GAAkBI,EAAU,WAAWL,CAAgB,GAAKM,EAAQ,SAASL,CAAc,EAC/GC,EAAgB,GAChBC,EAAmBpF,EAAO,SAAS,CAAE,KAAMU,EAAK,KAAM,GAAI,CAAE,EAAG,CAAE,KAAMiB,EAAG,KAAM,GAAI3B,EAAO,QAAQ2B,EAAG,IAAI,EAAE,MAAO,CAAC,MAEpH,SAAW0D,KAAS9F,EAChB,GAAI8F,EAAM,OAASA,EAAM,KAAOC,EAAU,WAAWD,EAAM,KAAK,GAAKE,EAAQ,SAASF,EAAM,GAAG,EAAG,CAC9FJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmBpF,EAAO,SAAS,CAAE,KAAMU,EAAK,KAAM,GAAI,CAAE,EAAG,CAAE,KAAMiB,EAAG,KAAM,GAAI3B,EAAO,QAAQ2B,EAAG,IAAI,EAAE,MAAO,CAAC,EACpH,KACJ,CAGZ,CACJ,SAAWqD,GAAWpD,EAAY,CAC9B,GAAIqD,GAAoBC,GAAkBhE,EAAK,WAAW+D,CAAgB,GAAK/D,EAAK,SAASgE,CAAc,EACvGC,EAAgB,GAChBC,EAAmBlE,MAEnB,SAAWmE,KAAS9F,EAChB,GAAI8F,EAAM,OAASA,EAAM,KAAOnE,EAAK,WAAWmE,EAAM,KAAK,GAAKnE,EAAK,SAASmE,EAAM,GAAG,EAAG,CACtFJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmBlE,EACnB,KACJ,CAGR,GAAI,CAACiE,GAAiBF,GAAoBC,GAAkBxD,EAAK,WAAWuD,CAAgB,GAAKvD,EAAK,SAASwD,CAAc,EACzHC,EAAgB,GAChBC,EAAmB1D,UACZ,CAACyD,GACR,QAAWE,KAAS9F,EAChB,GAAI8F,EAAM,OAASA,EAAM,KAAO3D,EAAK,WAAW2D,EAAM,KAAK,GAAK3D,EAAK,SAAS2D,EAAM,GAAG,EAAG,CACtFJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmB1D,EACnB,KACJ,EAGZ,SACQuD,GAAoBC,GAAkBhE,EAAK,WAAW+D,CAAgB,GAAK/D,EAAK,SAASgE,CAAc,EACvGC,EAAgB,GAChBC,EAAmBlE,MAEnB,SAAWmE,KAAS9F,EAChB,GAAI8F,EAAM,OAASA,EAAM,KAAOnE,EAAK,WAAWmE,EAAM,KAAK,GAAKnE,EAAK,SAASmE,EAAM,GAAG,EAAG,CACtFJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmBlE,EACnB,KACJ,CAIZ,SAASsE,GAAwC9D,EAActB,EAAeC,EAAaoF,EAAwBC,EAA4E,CAC3L,MAAO,CAAE,OAAQhE,EAAM,SAAU+D,EAAgB,OAAQC,CAAa,CAC1E,CACA,GAAIP,EAAe,CACf,GAAI3D,GAAayD,GAAoBG,IAAqBH,EAAkB,CACxE,IAAM9B,EAAWnD,EAAO,QAAQU,EAAK,IAAI,EACnC6C,EAAWJ,EAAS,QAAQ8B,CAAgB,EAC5CzB,EAAS0B,EAAiB/B,EAAS,QAAQ+B,EAAgB3B,EAAW0B,EAAiB,MAAM,EAAI,GACvG,GAAIzB,IAAW,GAAI,CACf,IAAMmC,EAAUxC,EAAS,MAAMI,EAAW0B,EAAiB,OAAQzB,CAAM,EACzE,GAAI,QAAQ,KAAKmC,CAAO,EAAG,CACvBtG,EAAO,kDAAmD,CAAE,KAAMqB,EAAK,KAAM,SAAA6C,EAAU,OAAAC,EAAQ,iBAAAyB,EAAkB,eAAAC,CAAe,CAAC,EACjI,IAAMrF,EAASsD,EAAS,MAAM,EAAGI,CAAQ,EACnCzD,EAAQqD,EAAS,MAAMK,EAAS0B,EAAe,MAAM,EAC3DlF,EAAO,QAAQU,EAAK,KAAMb,EAASC,CAAK,EACxCE,EAAO,UAAU,CAAE,KAAMU,EAAK,KAAM,GAAI6C,CAAS,CAAC,EAClD,MACJ,CACJ,CACJ,CACA,MACJ,CACA,IAAIqC,EAAYxE,EACZyE,GAAUxE,EACVyE,EAAS,GACTC,EAAYrE,EAQhB,GAPIF,EACAuE,EAAYrE,EACLsD,GAAWpD,EAClBmE,EAAY7E,EAAK,MAAMU,EAAW,MAAOA,EAAW,GAAG,EAEvDmE,EAAYrE,EAEZkE,GAAa5D,GAAqB+D,EAAWH,EAAWC,EAAO,EAC/DC,EAAS,OAET,SAAWT,KAAS9F,EAChB,GAAI8F,EAAM,OAASrD,GAAqB+D,EAAWV,EAAM,MAAOA,EAAM,GAAG,EAAG,CACxEO,EAAYP,EAAM,MAClBQ,GAAUR,EAAM,IAChBS,EAAS,GACT,KACJ,CAGR,SAASE,GAAetE,EAAc,CAClC,OAAON,EAAc,IAAMM,EAAO,IAAML,CAC5C,CACA,SAAS4E,EAAehE,EAAa,CACjC,IAAM7B,EAAQgB,EAAc,IACtBf,EAAM,IAAMgB,EAClB,OAAIY,EAAI,WAAW7B,CAAK,GAAK6B,EAAI,SAAS5B,CAAG,EAClC4B,EAAI,MAAM7B,EAAM,OAAQ6B,EAAI,OAAS5B,EAAI,MAAM,EAEtD4B,EAAI,WAAWb,CAAW,GAAKa,EAAI,SAASZ,CAAS,EAC9CY,EAAI,MAAMb,EAAY,OAAQa,EAAI,OAASZ,EAAU,MAAM,EAAE,KAAK,EAEtE,IACX,CACA,IAAI6E,EAAc,KAClB,GAAI1E,EACA0E,EAAcD,EAAevE,CAAI,EAC7BwE,IAAgB,OAAMJ,EAAS,YAC5Bd,GAAWpD,EAAY,CAC9B,IAAMuE,EAAWjF,EAAK,MAAMU,EAAW,MAAOA,EAAW,GAAG,EAC5DsE,EAAcD,EAAeE,CAAQ,EACjCD,IAAgB,OAAMJ,EAAS,GACvC,MACII,EAAcD,EAAevE,CAAI,EAC7BwE,IAAgB,OAAMJ,EAAS,IAEvC,GAAIA,EAAQ,CACR,IAAMM,EAAkBF,IAAgB,KAAOA,EAAcxE,EAC7D,GAAIF,EAAW,CACXxB,EAAO,iBAAiBoG,CAAe,EACvC,IAAMC,EAAUtF,EAAeL,CAAI,EAC7B4F,EAAQvF,EAAe,CAAE,KAAMY,EAAG,KAAM,GAAIjB,EAAK,GAAK0F,EAAgB,MAAO,CAAC,EACpFpG,EAAO,aAAaqG,EAASC,CAAK,CACtC,SAAWtB,GAAWpD,EAAY,CAC9B5B,EAAO,aAAaoG,EAAiB,CAAE,KAAM3E,EAAO,KAAM,GAAIG,EAAW,KAAM,EAAG,CAAE,KAAMH,EAAO,KAAM,GAAIG,EAAW,GAAI,CAAC,EAC3H,IAAM2E,EAAQ3E,EAAW,MAAQwE,EAAgB,OAC3CrB,EAAUhE,EAAe,CAAE,KAAMU,EAAO,KAAM,GAAI8E,CAAM,CAAC,EAC/DvG,EAAO,UAAU+E,CAAO,CAC5B,KAAO,CACH/E,EAAO,aAAaoG,EAAiB,CAAE,KAAM3E,EAAO,KAAM,GAAIA,EAAO,EAAG,EAAG,CAAE,KAAMA,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EAC/G,IAAMsD,EAAUhE,EAAe,CAAE,KAAMU,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EACnEzB,EAAO,UAAU+E,CAAO,CAC5B,CACJ,KAAO,CACH,IAAIyB,EAAc9E,EAAK,KAAK,EACxB+E,EAMJ,GALI,CAACjF,GAAa,CAACgF,EACfC,EAAYrF,EAAc,KAAOC,EAEjCoF,EAAYT,GAAeQ,CAAW,EAEtC,CAAChF,GAAa,CAACgF,EAAa,CAC5BxG,EAAO,aAAayG,EAAW,CAAE,KAAMhF,EAAO,KAAM,GAAIA,EAAO,EAAG,EAAG,CAAE,KAAMA,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EACzG,IAAMiF,EAAYjF,EAAO,IAAML,EAAc,KAAK,OAC5C2D,EAAUhE,EAAe,CAAE,KAAMU,EAAO,KAAM,GAAIiF,CAAU,CAAC,EACnE1G,EAAO,UAAU+E,CAAO,CAC5B,SAAWvD,EAAW,CAClBxB,EAAO,iBAAiByG,CAAS,EACjC,IAAME,GAAevF,EAAc,KAAK,OAClCiF,EAAUtF,EAAe,CAAE,KAAML,EAAK,KAAM,GAAIA,EAAK,GAAKiG,CAAY,CAAC,EACvEL,EAAQvF,EAAe,CAAE,KAAMY,EAAG,KAAM,GAAIjB,EAAK,GAAKiG,EAAcH,EAAY,MAAO,CAAC,EAC9FxG,EAAO,aAAaqG,EAASC,CAAK,CACtC,SAAWtB,GAAWpD,EAAY,CAC9B5B,EAAO,aAAayG,EAAW,CAAE,KAAMhF,EAAO,KAAM,GAAIG,EAAW,KAAM,EAAG,CAAE,KAAMH,EAAO,KAAM,GAAIG,EAAW,GAAI,CAAC,EACrH,IAAM2E,EAAQ3E,EAAW,OAASR,EAAc,KAAK,OAC/C2D,EAAUhE,EAAe,CAAE,KAAMU,EAAO,KAAM,GAAI8E,CAAM,CAAC,EAC/DvG,EAAO,UAAU+E,CAAO,CAC5B,KAAO,CACH/E,EAAO,aAAayG,EAAW,CAAE,KAAMhF,EAAO,KAAM,GAAIA,EAAO,EAAG,EAAG,CAAE,KAAMA,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EACzG,IAAMsD,EAAUhE,EAAe,CAAE,KAAMU,EAAO,KAAM,GAAIA,EAAO,IAAML,EAAc,KAAK,MAAO,CAAC,EAChGpB,EAAO,UAAU+E,CAAO,CAC5B,CACJ,CACA,IAAM6B,EAAc7F,EAAef,EAAO,UAAU,CAAC,GACjD4G,EAAY,OAAS5G,EAAO,UAAU,EAAE,MAAQ4G,EAAY,KAAO5G,EAAO,UAAU,EAAE,KACtFA,EAAO,UAAU4G,CAAW,CAEpC,CAMA,sBAAsB5G,EAAgB,CAClC,IAAMQ,EAAW,KAAK,SAAS,SACzBZ,EAAcY,EAAS,QAAQ,UAAU,EAC3CX,EAASW,EACTV,EAAQ,GACRF,IAAgB,KAChBC,EAASW,EAAS,MAAM,EAAGZ,CAAW,EACtCE,EAAQU,EAAS,MAAMZ,EAAc,CAAiB,GAE1D,IAAMwB,EAAcvB,EAAO,KAAK,EAC1BwB,EAAYvB,EAAM,KAAK,EAEvB2B,EAASzB,EAAO,UAAU,EAC5BkB,EAAOlB,EAAO,QAAQyB,EAAO,IAAI,EACjC8B,EAAWrC,EAAK,QAAQE,CAAW,EACnCoC,EAASnC,EAAYH,EAAK,YAAYG,CAAS,EAAI,GACnDwF,EAAW,GAMf,GALIzF,GAAeC,EACfwF,EAAWtD,IAAa,IAAMC,IAAW,IAAM/B,EAAO,IAAM8B,EAAWnC,EAAY,QAAUK,EAAO,IAAM+B,EACnGpC,IACPyF,EAAWtD,IAAa,IAAM9B,EAAO,IAAM8B,EAAWnC,EAAY,QAElEyF,EAAU,CACV,IAAIX,EAAchF,EACdE,IACA8E,EAAcA,EAAY,QAAQ9E,EAAa,EAAE,GAEjDC,IACA6E,EAAcA,EAAY,QAAQ7E,EAAW,EAAE,GAEnD6E,EAAcA,EAAY,KAAK,EAC/BlG,EAAO,QAAQyB,EAAO,KAAMyE,CAAW,CAC3C,CACJ,CACJ",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "logDev", "args", "defaultStyles", "CommentFormatPlugin", "CommentFormatSettingTab", "force", "mainTemplate", "cursorIndex", "before", "after", "mainId", "editor", "marker", "i", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "template", "commentText", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "clampCursorPos", "pos", "allLines", "line", "ch", "markerStart", "markerEnd", "markerStartNormalized", "markerEndNormalized", "selection", "cursor", "text", "to", "wordBounds", "getWordBounds", "regex", "match", "isTextCommentedExact", "str", "scanForFirst", "fromLine", "fromCh", "opposite", "direction", "markerTrim", "oppositeTrim", "l", "searchStart", "idx", "isComment", "commentStartPos", "commentEndPos", "beforeType", "afterType", "containsPartOfMarker", "sel", "lineText", "selectionText", "foundStart", "foundEnd", "startIdx", "endIdx", "left", "right", "searchLine", "searchCh", "found", "atStartBoundary", "atEndBoundary", "startLineIdx", "startChIdx", "endLineIdx", "endChIdx", "startLine", "startMarkerWithSpace", "updatedLine", "endMarkerWithSpace", "endLine", "toLine", "newText", "newCursorLine", "newCursorCh", "lastLine", "lineLen", "clamped", "useWord", "removalUsedStart", "removalUsedEnd", "removalInside", "removalCheckText", "style", "lineStart", "lineEnd", "removeNearestMarkersFromWordOrSelection", "selectionStart", "selectionEnd", "between", "usedStart", "usedEnd", "inside", "checkText", "buildCommented", "stripCommented", "uncommented", "wordText", "safeUncommented", "selFrom", "selTo", "newCh", "trimmedText", "commented", "cursorPos", "startOffset", "finalCursor", "isInside"]
}
