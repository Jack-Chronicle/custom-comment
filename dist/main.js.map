{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect, RangeSetBuilder } from '@codemirror/state';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default fallback comment styles for removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\n/**\r\n * Main plugin class for Custom Comments.\r\n * Handles command registration, settings, and comment toggling logic.\r\n */\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n    private _cleanupGuard: boolean = false;\r\n\r\n    /**\r\n     * Called when the plugin is loaded. Registers commands and settings tab.\r\n     */\r\n    async onload() {\r\n        logDev('Plugin loading...');\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        this.registerMarkerCommands();\r\n        // Removed: auto-cleanup event registration\r\n    }\r\n\r\n    /**\r\n     * Registers all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        if (force && this._markerCommandIds) {\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Register main toggle command\r\n        let mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Register additional marker commands if enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n        logDev('Marker commands registered:', this._markerCommandIds);\r\n    }\r\n\r\n    /**\r\n     * Loads plugin settings from disk.\r\n     */\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n        logDev('Settings loaded:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Saves plugin settings to disk.\r\n     */\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n        logDev('Settings saved:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n        logDev('Plugin reloaded');\r\n    }\r\n\r\n    /**\r\n     * Inserts a comment at the current cursor position using the template.\r\n     */\r\n    insertComment(editor: Editor) {\r\n        let template = this.settings.template;\r\n        let cursorIndex = template.indexOf(\"{cursor}\");\r\n        if (cursorIndex === -1) {\r\n            editor.replaceSelection(template);\r\n            logDev('Inserted template (no cursor placeholder)');\r\n            return;\r\n        }\r\n        let before = template.slice(0, cursorIndex).trim();\r\n        let after = template.slice(cursorIndex + \"{cursor}\".length).trim();\r\n        const commentText = `${before} ${after}`.replace(/\\s+/g, ' ').trim();\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(`${before}  ${after}`.replace(/\\s+/g, ' ').replace(' ', ' {cursor} '));\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length + 1;\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n        logDev('Inserted comment at cursor');\r\n    }\r\n\r\n    /**\r\n     * Toggles comment using a specific marker set, or the default template if none provided.\r\n     * Handles selection, word, and cursor modes robustly.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n\r\n        // 1. Marker Extraction and Normalization\r\n        let markerStart: string, markerEnd: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start.trim();\r\n            markerEnd = markerSet.end.trim();\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before.trim();\r\n            markerEnd = after.trim();\r\n        }\r\n        function normalize(str: string) {\r\n            return str.replace(/\\s+/g, ' ').trim();\r\n        }\r\n        const normStart = normalize(markerStart);\r\n        const normEnd = normalize(markerEnd);\r\n\r\n        // 3.1 Marker Search in Selection\r\n        function findMarkerInText(marker: string, text: string) {\r\n            let idx = text.indexOf(marker);\r\n            if (idx !== -1) return { idx, full: true };\r\n            // Try partials (from length-1 down to 1)\r\n            for (let len = marker.length - 1; len > 0; len--) {\r\n                if (text.includes(marker.slice(0, len))) return { idx: text.indexOf(marker.slice(0, len)), full: false, partial: marker.slice(0, len) };\r\n                if (text.includes(marker.slice(-len))) return { idx: text.indexOf(marker.slice(-len)), full: false, partial: marker.slice(-len) };\r\n            }\r\n            return { idx: -1, full: false };\r\n        }\r\n        // --- Advanced Partial Marker Detection ---\r\n        function confirmPartialMarker({\r\n            line,\r\n            marker,\r\n            partialIdx,\r\n            isStart,\r\n            otherMarker,\r\n            uniqueMarkers = true\r\n        }: {\r\n            line: string,\r\n            marker: string,\r\n            partialIdx: number,\r\n            isStart: boolean,\r\n            otherMarker: string,\r\n            uniqueMarkers?: boolean\r\n        }) {\r\n            const len = marker.length;\r\n            let fullIdx = -1;\r\n            for (let i = Math.max(0, partialIdx - len + 1); i <= partialIdx; i++) {\r\n                if (line.slice(i, i + len) === marker) {\r\n                    fullIdx = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (fullIdx === -1) {\r\n                for (let i = partialIdx; i <= Math.min(line.length - len, partialIdx + len - 1); i++) {\r\n                    if (line.slice(i, i + len) === marker) {\r\n                        fullIdx = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (fullIdx === -1) return { confirmed: false };\r\n            if (isStart) {\r\n                let nextEnd = line.indexOf(otherMarker, fullIdx + len);\r\n                if (nextEnd === -1) return { confirmed: false };\r\n                if (uniqueMarkers) {\r\n                    let nextStart = line.indexOf(marker, fullIdx + len);\r\n                    if (nextStart !== -1 && nextStart < nextEnd) return { confirmed: false };\r\n                }\r\n                return { confirmed: true, startIdx: fullIdx, endIdx: nextEnd };\r\n            } else {\r\n                let prevStart = line.lastIndexOf(otherMarker, fullIdx - 1);\r\n                if (prevStart === -1) return { confirmed: false };\r\n                if (uniqueMarkers) {\r\n                    let prevEnd = line.lastIndexOf(marker, fullIdx - 1);\r\n                    if (prevEnd !== -1 && prevEnd > prevStart) return { confirmed: false };\r\n                }\r\n                return { confirmed: true, startIdx: prevStart, endIdx: fullIdx };\r\n            }\r\n        }\r\n        // --- Helper: Search for marker in line in a direction ---\r\n        function searchMarkerInLine(marker: string, fromIdx: number, direction: 'back' | 'forward'): number {\r\n            if (direction === 'back') {\r\n                return line.lastIndexOf(marker, fromIdx);\r\n            } else {\r\n                return line.indexOf(marker, fromIdx);\r\n            }\r\n        }\r\n\r\n        // 2. Efficient Comment Detection\r\n        function isRegionCommented(text: string, start: string, end: string) {\r\n            const trimmed = text.trim();\r\n            if (start && end) {\r\n                return trimmed.startsWith(start) && trimmed.endsWith(end);\r\n            } else if (start) {\r\n                return trimmed.startsWith(start);\r\n            }\r\n            return false;\r\n        }\r\n        // fallback style detection\r\n        function detectFallback(text: string) {\r\n            for (const style of defaultStyles) {\r\n                const s = normalize(style.start);\r\n                const e = normalize(style.end);\r\n                if (isRegionCommented(text, s, e)) {\r\n                    return { found: true, markerStart: style.start, markerEnd: style.end };\r\n                }\r\n            }\r\n            return { found: false };\r\n        }\r\n\r\n        // 3. Mode Decision\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let line = editor.getLine(cursor.line);\r\n        let text: string;\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        if (selection) {\r\n            text = selection;\r\n        } else {\r\n            wordBounds = getWordBounds(line, cursor.ch);\r\n            if (wordBounds && cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                text = line.slice(wordBounds.start, wordBounds.end);\r\n                from = { line: cursor.line, ch: wordBounds.start };\r\n                to = { line: cursor.line, ch: wordBounds.end };\r\n            } else {\r\n                text = '';\r\n                from = { line: cursor.line, ch: cursor.ch };\r\n                to = { line: cursor.line, ch: cursor.ch };\r\n            }\r\n        }\r\n\r\n        // 4. Comment Region Detection\r\n        let startIdx = -1, endIdx = -1;\r\n        let region = '', regionIsComment = false;\r\n        let usedStart = normStart, usedEnd = normEnd;\r\n        let uniqueMarkers = Boolean(usedStart && usedEnd && usedStart !== usedEnd);\r\n        // --- Detection Logging ---\r\n        logDev('[Detection] selection:', selection);\r\n        logDev('[Detection] text:', text);\r\n        const foundStart = findMarkerInText(normStart, text);\r\n        const foundEnd = findMarkerInText(normEnd, text);\r\n        logDev('[Detection] foundStart:', foundStart);\r\n        logDev('[Detection] foundEnd:', foundEnd);\r\n        if (selection) {\r\n            if (foundStart.full && foundEnd.full) {\r\n                logDev('[Detection] Both full markers found in selection.');\r\n                // Full marker in selection: search back from selection end for start, forward from selection start for end\r\n                startIdx = searchMarkerInLine(normStart, to.ch, 'back');\r\n                endIdx = searchMarkerInLine(normEnd, from.ch, 'forward');\r\n            } else if (foundStart.full) {\r\n                logDev('[Detection] Only full start marker found in selection.');\r\n                // Only full start marker in selection: search forward from end of start marker for end marker\r\n                const startInSel = text.indexOf(normStart);\r\n                if (startInSel !== -1) {\r\n                    startIdx = from.ch + startInSel;\r\n                    endIdx = searchMarkerInLine(normEnd, startIdx + normStart.length, 'forward');\r\n                }\r\n            } else if (foundEnd.full) {\r\n                logDev('[Detection] Only full end marker found in selection.');\r\n                // Only full end marker in selection: search backward from start of end marker for start marker\r\n                const endInSel = text.indexOf(normEnd);\r\n                if (endInSel !== -1) {\r\n                    endIdx = from.ch + endInSel;\r\n                    startIdx = searchMarkerInLine(normStart, endIdx, 'back');\r\n                }\r\n            } else if (foundStart.idx !== -1 && !foundStart.full) {\r\n                logDev('[Detection] Partial start marker found in selection.');\r\n                // Partial start: confirm partial\r\n                const conf = confirmPartialMarker({\r\n                    line,\r\n                    marker: normStart,\r\n                    partialIdx: from.ch + foundStart.idx,\r\n                    isStart: true,\r\n                    otherMarker: normEnd,\r\n                    uniqueMarkers\r\n                });\r\n                logDev('[Detection] confirmPartialMarker result (start):', conf);\r\n                if (conf.confirmed && conf.startIdx !== undefined && conf.endIdx !== undefined) {\r\n                    startIdx = conf.startIdx;\r\n                    endIdx = conf.endIdx;\r\n                } else if (foundStart.partial && normEnd.startsWith(foundStart.partial)) {\r\n                    // Try as partial end marker\r\n                    logDev('[Detection] Partial start marker did not confirm, trying as partial end marker.');\r\n                    const confEnd = confirmPartialMarker({\r\n                        line,\r\n                        marker: normEnd,\r\n                        partialIdx: from.ch + foundStart.idx,\r\n                        isStart: false,\r\n                        otherMarker: normStart,\r\n                        uniqueMarkers\r\n                    });\r\n                    logDev('[Detection] confirmPartialMarker result (as end):', confEnd);\r\n                    if (confEnd.confirmed && confEnd.startIdx !== undefined && confEnd.endIdx !== undefined) {\r\n                        startIdx = confEnd.startIdx;\r\n                        endIdx = confEnd.endIdx;\r\n                    }\r\n                }\r\n            } else if (foundEnd.idx !== -1 && !foundEnd.full) {\r\n                logDev('[Detection] Partial end marker found in selection.');\r\n                // Partial end: confirm partial\r\n                const conf = confirmPartialMarker({\r\n                    line,\r\n                    marker: normEnd,\r\n                    partialIdx: to.ch + foundEnd.idx,\r\n                    isStart: false,\r\n                    otherMarker: normStart,\r\n                    uniqueMarkers\r\n                });\r\n                logDev('[Detection] confirmPartialMarker result (end):', conf);\r\n                if (conf.confirmed && conf.startIdx !== undefined && conf.endIdx !== undefined) {\r\n                    startIdx = conf.startIdx;\r\n                    endIdx = conf.endIdx;\r\n                } else if (foundEnd.partial && normStart.startsWith(foundEnd.partial)) {\r\n                    // Try as partial start marker\r\n                    logDev('[Detection] Partial end marker did not confirm, trying as partial start marker.');\r\n                    const confStart = confirmPartialMarker({\r\n                        line,\r\n                        marker: normStart,\r\n                        partialIdx: to.ch + foundEnd.idx,\r\n                        isStart: true,\r\n                        otherMarker: normEnd,\r\n                        uniqueMarkers\r\n                    });\r\n                    logDev('[Detection] confirmPartialMarker result (as start):', confStart);\r\n                    if (confStart.confirmed && confStart.startIdx !== undefined && confStart.endIdx !== undefined) {\r\n                        startIdx = confStart.startIdx;\r\n                        endIdx = confStart.endIdx;\r\n                    }\r\n                }\r\n            } else {\r\n                logDev('[Detection] No marker found in selection, searching line.');\r\n                // No marker: search back from end for start, forward from start for end\r\n                startIdx = searchMarkerInLine(normStart, to.ch, 'back');\r\n                endIdx = searchMarkerInLine(normEnd, from.ch, 'forward');\r\n            }\r\n        } else if (wordBounds) {\r\n            // Use word boundary as selection\r\n            startIdx = searchMarkerInLine(normStart, wordBounds.start, 'back');\r\n            endIdx = searchMarkerInLine(normEnd, wordBounds.end, 'forward');\r\n        } else {\r\n            // Cursor\r\n            startIdx = searchMarkerInLine(normStart, cursor.ch, 'back');\r\n            endIdx = searchMarkerInLine(normEnd, cursor.ch, 'forward');\r\n            // --- Enhanced: Check if cursor is adjacent to any marker character ---\r\n            if (startIdx === -1 && endIdx === -1 && normStart && normEnd) {\r\n                // ...existing code...\r\n            }\r\n            // --- NEW: If text is empty (no selection/word), check if cursor is inside a comment region in the full line ---\r\n            if (!selection && !wordBounds && !text.trim() && normStart && normEnd) {\r\n                const fullStartIdx = line.indexOf(normStart);\r\n                const fullEndIdx = normEnd ? line.lastIndexOf(normEnd) : -1;\r\n                if (\r\n                    fullStartIdx !== -1 &&\r\n                    fullEndIdx !== -1 &&\r\n                    cursor.ch >= fullStartIdx + normStart.length &&\r\n                    cursor.ch <= fullEndIdx + normEnd.length\r\n                ) {\r\n                    startIdx = fullStartIdx;\r\n                    endIdx = fullEndIdx;\r\n                }\r\n            }\r\n        }\r\n\r\n        // After detection, log the final indices and region\r\n        logDev('[Detection] startIdx:', startIdx, 'endIdx:', endIdx);\r\n        logDev('[Detection] region:', region);\r\n        logDev('[Detection] regionIsComment:', regionIsComment);\r\n\r\n        // If both valid, extract region and check if commented\r\n        if (startIdx !== -1 && (usedEnd ? endIdx !== -1 && startIdx < endIdx : true)) {\r\n            const regionStart = startIdx + normStart.length;\r\n            const regionEnd = usedEnd && endIdx !== -1 ? endIdx : line.length;\r\n            region = line.slice(regionStart, regionEnd);\r\n            if (isRegionCommented(line.slice(startIdx, (usedEnd && endIdx !== -1 ? endIdx + normEnd.length : line.length)), normStart, normEnd)) {\r\n                regionIsComment = true;\r\n            }\r\n        } else {\r\n            // Try fallback styles\r\n            const fallback = detectFallback(line);\r\n            if (fallback.found) {\r\n                usedStart = fallback.markerStart ? normalize(fallback.markerStart) : '';\r\n                usedEnd = fallback.markerEnd ? normalize(fallback.markerEnd) : '';\r\n                startIdx = searchMarkerInLine(usedStart, cursor.ch, 'back');\r\n                endIdx = searchMarkerInLine(usedEnd, cursor.ch, 'forward');\r\n                if (startIdx !== -1 && (usedEnd ? endIdx !== -1 && startIdx < endIdx : true)) {\r\n                    const regionStart = startIdx + usedStart.length;\r\n                    const regionEnd = usedEnd && endIdx !== -1 ? endIdx : line.length;\r\n                    region = line.slice(regionStart, regionEnd);\r\n                    if (isRegionCommented(line.slice(startIdx, (usedEnd && endIdx !== -1 ? endIdx + usedEnd.length : line.length)), usedStart, usedEnd)) {\r\n                        regionIsComment = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 5. Toggle Logic\r\n        if (regionIsComment) {\r\n            // Remove markers, and also remove spaces that were added with the markers\r\n            let beforeRegion = line.slice(0, startIdx);\r\n            let afterRegion = line.slice((usedEnd && endIdx !== -1 ? endIdx + usedEnd.length : line.length));\r\n            // Remove a single space after the start marker if present\r\n            let startMarkerExtra = 0;\r\n            if (region.startsWith(' ')) {\r\n                region = region.slice(1);\r\n                startMarkerExtra = 1;\r\n            }\r\n            // Remove a single space before the end marker if present\r\n            let endMarkerExtra = 0;\r\n            if (region.endsWith(' ')) {\r\n                region = region.slice(0, -1);\r\n                endMarkerExtra = 1;\r\n            }\r\n            let newLine = beforeRegion + region + afterRegion;\r\n            editor.setLine(cursor.line, newLine);\r\n            // 6. Cursor Management (restore relative position)\r\n            if (selection) {\r\n                // If the selection included any part of the start or end marker, shrink it to exclude them\r\n                let selFromCh = from.ch;\r\n                let selToCh = to.ch;\r\n                // If selection starts before or at the start marker, move to after marker\r\n                if (from.ch <= startIdx + usedStart.length + startMarkerExtra) {\r\n                    selFromCh = startIdx;\r\n                } else {\r\n                    selFromCh = from.ch - usedStart.length - startMarkerExtra;\r\n                }\r\n                // If selection ends after or at the end marker, move to before marker\r\n                if (usedEnd && endIdx !== -1 && to.ch >= endIdx) {\r\n                    selToCh = startIdx + region.length;\r\n                } else {\r\n                    selToCh = to.ch - usedStart.length - startMarkerExtra;\r\n                }\r\n                // Clamp\r\n                selFromCh = Math.max(0, selFromCh);\r\n                selToCh = Math.max(selFromCh, selToCh);\r\n                const selFrom = { line: cursor.line, ch: selFromCh };\r\n                const selTo = { line: cursor.line, ch: selToCh };\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (wordBounds) {\r\n                // Select the word region after uncommenting\r\n                const selFrom = { line: cursor.line, ch: beforeRegion.length };\r\n                const selTo = { line: cursor.line, ch: beforeRegion.length + region.length };\r\n                editor.setSelection(selFrom, selTo);\r\n            } else {\r\n                // Cursor: select the uncommented text (region)\r\n                const selFrom = { line: cursor.line, ch: beforeRegion.length };\r\n                const selTo = { line: cursor.line, ch: beforeRegion.length + region.length };\r\n                editor.setSelection(selFrom, selTo);\r\n            }\r\n            logDev('Uncommented region', { from, to, region });\r\n        } else {\r\n            // Insert markers, preserve whitespace inside selection/word\r\n            let innerText = text;\r\n            if (!selection && !wordBounds && !text.trim()) innerText = '';\r\n            let commented: string;\r\n            let newLine;\r\n            if (selection) {\r\n                // Multi-line selection: wrap the selection in markers, not just the current line\r\n                const selText = editor.getRange(from, to);\r\n                commented = usedStart + (selText ? ' ' : '') + selText + (selText ? ' ' : '') + usedEnd;\r\n                editor.replaceRange(commented, from, to);\r\n                // After insertion, select the same text as before (excluding the markers)\r\n                const startMarkerLen = usedStart.length + (selText ? 1 : 0);\r\n                const endMarkerLen = usedEnd.length + (selText ? 1 : 0);\r\n                // Compute new selection bounds\r\n                const selFrom = { line: from.line, ch: from.ch + startMarkerLen };\r\n                // Calculate the end position after insertion\r\n                let selTo;\r\n                if (from.line === to.line) {\r\n                    selTo = { line: to.line, ch: to.ch + startMarkerLen };\r\n                } else {\r\n                    // For multi-line, selection end shifts by start marker on first line only\r\n                    selTo = { line: to.line, ch: to.ch };\r\n                }\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (wordBounds && this.settings.wordOnlyMode) {\r\n                // Word only mode: treat word as selection (add spaces around word)\r\n                commented = usedStart + ' ' + line.slice(wordBounds.start, wordBounds.end) + ' ' + usedEnd;\r\n                newLine = line.slice(0, wordBounds.start) + commented + line.slice(wordBounds.end);\r\n                editor.setLine(cursor.line, newLine);\r\n                // Select the word inside the comment\r\n                const selFrom = { line: cursor.line, ch: wordBounds.start + usedStart.length + 1 };\r\n                const selTo = { line: cursor.line, ch: wordBounds.start + usedStart.length + 1 + (wordBounds.end - wordBounds.start) };\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (wordBounds) {\r\n                // Not word only mode: treat as cursor insert (no spaces around word)\r\n                commented = usedStart + '  ' + usedEnd;\r\n                newLine = line.slice(0, cursor.ch) + commented + line.slice(cursor.ch);\r\n                editor.setLine(cursor.line, newLine);\r\n                // Place cursor between the two spaces\r\n                editor.setCursor({ line: cursor.line, ch: cursor.ch + usedStart.length + 1 });\r\n            } else {\r\n                commented = usedStart + '  ' + usedEnd;\r\n                newLine = line.slice(0, cursor.ch) + commented + line.slice(cursor.ch);\r\n                editor.setLine(cursor.line, newLine);\r\n                // Place cursor between the two spaces\r\n                editor.setCursor({ line: cursor.line, ch: cursor.ch + usedStart.length + 1 });\r\n            }\r\n            logDev('Commented region', { from, to, commented });\r\n        }\r\n\r\n        // 6. Clamp cursor to valid position\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            // Fix: allow cursor to be anywhere between start marker end and end marker end\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx + markerEnd.length;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "logDev", "args", "defaultStyles", "CommentFormatPlugin", "CommentFormatSettingTab", "force", "mainTemplate", "cursorIndex", "before", "after", "mainId", "editor", "marker", "i", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "template", "commentText", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "markerStart", "markerEnd", "normalize", "str", "normStart", "normEnd", "findMarkerInText", "text", "idx", "len", "confirmPartialMarker", "line", "partialIdx", "isStart", "otherMarker", "uniqueMarkers", "fullIdx", "nextEnd", "nextStart", "prevStart", "prevEnd", "searchMarkerInLine", "fromIdx", "direction", "isRegionCommented", "trimmed", "detectFallback", "style", "s", "e", "selection", "cursor", "to", "wordBounds", "getWordBounds", "ch", "regex", "match", "startIdx", "endIdx", "region", "regionIsComment", "usedStart", "usedEnd", "foundStart", "foundEnd", "startInSel", "endInSel", "conf", "confEnd", "confStart", "fullStartIdx", "fullEndIdx", "regionStart", "regionEnd", "fallback", "beforeRegion", "afterRegion", "startMarkerExtra", "endMarkerExtra", "newLine", "selFromCh", "selToCh", "selFrom", "selTo", "innerText", "commented", "selText", "startMarkerLen", "endMarkerLen", "clampCursorPos", "pos", "allLines", "finalCursor", "isInside", "uncommented"]
}
