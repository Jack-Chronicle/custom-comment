{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect, RangeSetBuilder } from '@codemirror/state';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default fallback comment styles for removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\n/**\r\n * Main plugin class for Custom Comments.\r\n * Handles command registration, settings, and comment toggling logic.\r\n */\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n    private _cleanupGuard: boolean = false;\r\n\r\n    /**\r\n     * Called when the plugin is loaded. Registers commands and settings tab.\r\n     */\r\n    async onload() {\r\n        logDev('Plugin loading...');\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        this.registerMarkerCommands();\r\n        // Removed: auto-cleanup event registration\r\n    }\r\n\r\n    /**\r\n     * Registers all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        if (force && this._markerCommandIds) {\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Register main toggle command\r\n        let mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Register additional marker commands if enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n        logDev('Marker commands registered:', this._markerCommandIds);\r\n    }\r\n\r\n    /**\r\n     * Loads plugin settings from disk.\r\n     */\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n        logDev('Settings loaded:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Saves plugin settings to disk.\r\n     */\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n        logDev('Settings saved:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n        logDev('Plugin reloaded');\r\n    }\r\n\r\n    /**\r\n     * Inserts a comment at the current cursor position using the template.\r\n     */\r\n    insertComment(editor: Editor) {\r\n        let template = this.settings.template;\r\n        let cursorIndex = template.indexOf(\"{cursor}\");\r\n        if (cursorIndex === -1) {\r\n            editor.replaceSelection(template);\r\n            logDev('Inserted template (no cursor placeholder)');\r\n            return;\r\n        }\r\n        let before = template.slice(0, cursorIndex).trim();\r\n        let after = template.slice(cursorIndex + \"{cursor}\".length).trim();\r\n        const commentText = `${before} ${after}`.replace(/\\s+/g, ' ').trim();\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(`${before}  ${after}`.replace(/\\s+/g, ' ').replace(' ', ' {cursor} '));\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length + 1;\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n        logDev('Inserted comment at cursor');\r\n    }\r\n\r\n    /**\r\n     * Toggles comment using a specific marker set, or the default template if none provided.\r\n     * Handles selection, word, and cursor modes robustly.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n\r\n        // 1. Marker Extraction and Normalization\r\n        let markerStart: string, markerEnd: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start.trim();\r\n            markerEnd = markerSet.end.trim();\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before.trim();\r\n            markerEnd = after.trim();\r\n        }\r\n        function normalize(str: string) {\r\n            return str.replace(/\\s+/g, ' ').trim();\r\n        }\r\n        const normStart = normalize(markerStart);\r\n        const normEnd = normalize(markerEnd);\r\n\r\n        // 2. Efficient Comment Detection\r\n        function isRegionCommented(text: string, start: string, end: string) {\r\n            const trimmed = text.trim();\r\n            if (start && end) {\r\n                return trimmed.startsWith(start) && trimmed.endsWith(end);\r\n            } else if (start) {\r\n                return trimmed.startsWith(start);\r\n            }\r\n            return false;\r\n        }\r\n        // fallback style detection\r\n        function detectFallback(text: string) {\r\n            for (const style of defaultStyles) {\r\n                const s = normalize(style.start);\r\n                const e = normalize(style.end);\r\n                if (isRegionCommented(text, s, e)) {\r\n                    return { found: true, markerStart: style.start, markerEnd: style.end };\r\n                }\r\n            }\r\n            return { found: false };\r\n        }\r\n\r\n        // 3. Mode Decision\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let line = editor.getLine(cursor.line);\r\n        let text: string;\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        if (selection) {\r\n            text = selection;\r\n        } else {\r\n            wordBounds = getWordBounds(line, cursor.ch);\r\n            if (wordBounds && cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                text = line.slice(wordBounds.start, wordBounds.end);\r\n                from = { line: cursor.line, ch: wordBounds.start };\r\n                to = { line: cursor.line, ch: wordBounds.end };\r\n            } else {\r\n                text = '';\r\n                from = { line: cursor.line, ch: cursor.ch };\r\n                to = { line: cursor.line, ch: cursor.ch };\r\n            }\r\n        }\r\n\r\n        // 3.1 Marker Search in Selection\r\n        function findMarkerInText(marker: string, text: string) {\r\n            let idx = text.indexOf(marker);\r\n            if (idx !== -1) return { idx, full: true };\r\n            // Try partials (from length-1 down to 1)\r\n            for (let len = marker.length - 1; len > 0; len--) {\r\n                if (text.includes(marker.slice(0, len))) return { idx: text.indexOf(marker.slice(0, len)), full: false };\r\n                if (text.includes(marker.slice(-len))) return { idx: text.indexOf(marker.slice(-len)), full: false };\r\n            }\r\n            return { idx: -1, full: false };\r\n        }\r\n\r\n        // 3.2 Marker Search in Document\r\n        function searchMarkerInLine(marker: string, startIdx: number, direction: 'back' | 'forward') {\r\n            if (!marker) return -1;\r\n            if (direction === 'back') {\r\n                for (let i = startIdx; i >= 0; i--) {\r\n                    if (line.slice(i, i + marker.length) === marker) return i;\r\n                }\r\n            } else {\r\n                for (let i = startIdx; i <= line.length - marker.length; i++) {\r\n                    if (line.slice(i, i + marker.length) === marker) return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        // 4. Comment Region Detection\r\n        let startIdx = -1, endIdx = -1;\r\n        let region = '', regionIsComment = false;\r\n        let usedStart = normStart, usedEnd = normEnd;\r\n        if (selection) {\r\n            // Marker search in selection\r\n            const foundStart = findMarkerInText(normStart, text);\r\n            const foundEnd = findMarkerInText(normEnd, text);\r\n            if (foundStart.full && foundEnd.full) {\r\n                // Full marker in selection: search back for start, forward for end\r\n                startIdx = searchMarkerInLine(normStart, from.ch, 'back');\r\n                endIdx = searchMarkerInLine(normEnd, to.ch, 'forward');\r\n            } else if (foundStart.idx !== -1) {\r\n                // Partial start: search back for start\r\n                startIdx = searchMarkerInLine(normStart, from.ch, 'back');\r\n                endIdx = searchMarkerInLine(normEnd, to.ch, 'forward');\r\n            } else if (foundEnd.idx !== -1) {\r\n                // Partial end: search forward for end\r\n                startIdx = searchMarkerInLine(normStart, from.ch, 'back');\r\n                endIdx = searchMarkerInLine(normEnd, to.ch, 'forward');\r\n            } else {\r\n                // No marker: search back from end for start, forward from start for end\r\n                startIdx = searchMarkerInLine(normStart, to.ch, 'back');\r\n                endIdx = searchMarkerInLine(normEnd, from.ch, 'forward');\r\n            }\r\n        } else if (wordBounds) {\r\n            // Use word boundary as selection\r\n            startIdx = searchMarkerInLine(normStart, wordBounds.start, 'back');\r\n            endIdx = searchMarkerInLine(normEnd, wordBounds.end, 'forward');\r\n        } else {\r\n            // Cursor\r\n            startIdx = searchMarkerInLine(normStart, cursor.ch, 'back');\r\n            endIdx = searchMarkerInLine(normEnd, cursor.ch, 'forward');\r\n        }\r\n        if (startIdx !== -1 && (usedEnd ? endIdx !== -1 && startIdx < endIdx : true)) {\r\n            // Extract region\r\n            const regionStart = startIdx + normStart.length;\r\n            const regionEnd = usedEnd && endIdx !== -1 ? endIdx : line.length;\r\n            region = line.slice(regionStart, regionEnd);\r\n            if (isRegionCommented(line.slice(startIdx, (usedEnd && endIdx !== -1 ? endIdx + normEnd.length : line.length)), normStart, normEnd)) {\r\n                regionIsComment = true;\r\n            }\r\n        } else {\r\n            // Try fallback styles\r\n            const fallback = detectFallback(line);\r\n            if (fallback.found) {\r\n                usedStart = fallback.markerStart ? normalize(fallback.markerStart) : '';\r\n                usedEnd = fallback.markerEnd ? normalize(fallback.markerEnd) : '';\r\n                startIdx = searchMarkerInLine(usedStart, cursor.ch, 'back');\r\n                endIdx = searchMarkerInLine(usedEnd, cursor.ch, 'forward');\r\n                if (startIdx !== -1 && (usedEnd ? endIdx !== -1 && startIdx < endIdx : true)) {\r\n                    const regionStart = startIdx + usedStart.length;\r\n                    const regionEnd = usedEnd && endIdx !== -1 ? endIdx : line.length;\r\n                    region = line.slice(regionStart, regionEnd);\r\n                    if (isRegionCommented(line.slice(startIdx, (usedEnd && endIdx !== -1 ? endIdx + usedEnd.length : line.length)), usedStart, usedEnd)) {\r\n                        regionIsComment = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 5. Toggle Logic\r\n        if (regionIsComment) {\r\n            // Remove markers, and also remove spaces that were added with the markers\r\n            let beforeRegion = line.slice(0, startIdx);\r\n            let afterRegion = line.slice((usedEnd && endIdx !== -1 ? endIdx + usedEnd.length : line.length));\r\n            // Remove a single space after the start marker if present\r\n            if (region.startsWith(' ')) region = region.slice(1);\r\n            // Remove a single space before the end marker if present\r\n            if (region.endsWith(' ')) region = region.slice(0, -1);\r\n            let newLine = beforeRegion + region + afterRegion;\r\n            editor.setLine(cursor.line, newLine);\r\n            // 6. Cursor Management (restore relative position)\r\n            let removedBefore = 0;\r\n            if (selection) {\r\n                const unclamped = beforeRegion.length;\r\n                const selFrom = { line: cursor.line, ch: unclamped };\r\n                const selTo = { line: cursor.line, ch: unclamped + region.length };\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (wordBounds) {\r\n                const unclamped = beforeRegion.length;\r\n                editor.setCursor({ line: cursor.line, ch: unclamped });\r\n            } else {\r\n                // Cursor: restore relative position\r\n                // Calculate how many chars were removed before the original cursor\r\n                removedBefore = (cursor.ch > startIdx ? Math.min(cursor.ch, startIdx + usedStart.length) - startIdx : 0) + usedStart.length;\r\n                let newCh = cursor.ch - removedBefore;\r\n                if (newCh < beforeRegion.length) newCh = beforeRegion.length;\r\n                editor.setCursor({ line: cursor.line, ch: newCh });\r\n            }\r\n            logDev('Uncommented region', { from, to, region });\r\n        } else {\r\n            // Insert markers, preserve whitespace inside selection/word\r\n            let innerText = text;\r\n            if (!selection && !wordBounds && !text.trim()) innerText = '';\r\n            let commented: string;\r\n            let newLine;\r\n            if (selection) {\r\n                commented = usedStart + (innerText ? ' ' : '') + innerText + (innerText ? ' ' : '') + usedEnd;\r\n                newLine = line.slice(0, from.ch) + commented + line.slice(to.ch);\r\n                editor.setLine(cursor.line, newLine);\r\n                const selFrom = { line: cursor.line, ch: from.ch + usedStart.length + (innerText ? 1 : 0) };\r\n                const selTo = { line: cursor.line, ch: from.ch + usedStart.length + (innerText ? 1 : 0) + innerText.length };\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (wordBounds && this.settings.wordOnlyMode) {\r\n                // Word only mode: treat word as selection (add spaces around word)\r\n                commented = usedStart + ' ' + line.slice(wordBounds.start, wordBounds.end) + ' ' + usedEnd;\r\n                newLine = line.slice(0, wordBounds.start) + commented + line.slice(wordBounds.end);\r\n                editor.setLine(cursor.line, newLine);\r\n                // Select the word inside the comment\r\n                const selFrom = { line: cursor.line, ch: wordBounds.start + usedStart.length + 1 };\r\n                const selTo = { line: cursor.line, ch: wordBounds.start + usedStart.length + 1 + (wordBounds.end - wordBounds.start) };\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (wordBounds) {\r\n                // Not word only mode: treat as cursor insert (no spaces around word)\r\n                commented = usedStart + '  ' + usedEnd;\r\n                newLine = line.slice(0, cursor.ch) + commented + line.slice(cursor.ch);\r\n                editor.setLine(cursor.line, newLine);\r\n                // Place cursor between the two spaces\r\n                editor.setCursor({ line: cursor.line, ch: cursor.ch + usedStart.length + 1 });\r\n            } else {\r\n                commented = usedStart + '  ' + usedEnd;\r\n                newLine = line.slice(0, cursor.ch) + commented + line.slice(cursor.ch);\r\n                editor.setLine(cursor.line, newLine);\r\n                // Place cursor between the two spaces\r\n                editor.setCursor({ line: cursor.line, ch: cursor.ch + usedStart.length + 1 });\r\n            }\r\n            logDev('Commented region', { from, to, commented });\r\n        }\r\n        // 6. Clamp cursor to valid position\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "logDev", "args", "defaultStyles", "CommentFormatPlugin", "CommentFormatSettingTab", "force", "mainTemplate", "cursorIndex", "before", "after", "mainId", "editor", "marker", "i", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "template", "commentText", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "markerStart", "markerEnd", "normalize", "str", "normStart", "normEnd", "isRegionCommented", "text", "trimmed", "detectFallback", "style", "s", "e", "selection", "cursor", "to", "line", "wordBounds", "getWordBounds", "ch", "regex", "match", "findMarkerInText", "idx", "len", "searchMarkerInLine", "startIdx", "direction", "endIdx", "region", "regionIsComment", "usedStart", "usedEnd", "foundStart", "foundEnd", "regionStart", "regionEnd", "fallback", "beforeRegion", "afterRegion", "newLine", "removedBefore", "unclamped", "selFrom", "selTo", "newCh", "innerText", "commented", "clampCursorPos", "pos", "allLines", "finalCursor", "isInside", "uncommented"]
}
