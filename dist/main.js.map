{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect } from '@codemirror/state';\r\n// @ts-ignore\r\nimport { RangeSetBuilder } from '@codemirror/state';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default styles for fallback removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n    private _cleanupGuard: boolean = false;\r\n\r\n    async onload() {\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register the reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        this.registerMarkerCommands();\r\n        // Listen for editor changes to auto-cleanup markers if needed\r\n        this.registerEvent(this.app.workspace.on('editor-change', (editor: Editor) => {\r\n            if (!editor) return;\r\n            // Only run if the editor is active and focused\r\n            if (editor.hasFocus && editor.hasFocus()) {\r\n                this.handleEditorChange(editor);\r\n            }\r\n        }));\r\n    }\r\n\r\n    handleEditorChange(editor: Editor) {\r\n        // --- Only trigger cleanup if selection/cursor is at marker boundary and marker is partially/fully deleted ---\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        const from = editor.getCursor(\"from\");\r\n        const to = editor.getCursor(\"to\");\r\n        const lineText = editor.getLine(cursor.line);\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let markerStart = template.slice(0, cursorIndex);\r\n        let markerEnd = template.slice(cursorIndex + \"{cursor}\".length);\r\n\r\n        // Helper: check if selection/cursor is at marker boundary\r\n        function isAtMarkerBoundary(sel: string, marker: string, line: string, from: number, to: number): boolean {\r\n            if (!marker) return false;\r\n            // At left boundary\r\n            if (from >= 0 && from <= marker.length && line.slice(from - marker.length, from) === marker) return true;\r\n            // At right boundary\r\n            if (to >= 0 && to <= line.length && line.slice(to, to + marker.length) === marker) return true;\r\n            // Selection contains part of marker at boundary\r\n            if (sel && marker.length > 0) {\r\n                for (let i = 1; i < marker.length; i++) {\r\n                    if (sel.startsWith(marker.slice(0, i)) || sel.endsWith(marker.slice(-i))) return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // Only trigger cleanup if selection/cursor is at marker boundary and marker is partially/fully deleted\r\n        let shouldCleanup = false;\r\n        if (selection) {\r\n            // Selection at marker boundary\r\n            shouldCleanup = isAtMarkerBoundary(selection, markerStart, lineText, from.ch, to.ch) ||\r\n                            isAtMarkerBoundary(selection, markerEnd, lineText, from.ch, to.ch);\r\n        } else {\r\n            // No selection: check if cursor is at marker boundary and marker is partially deleted\r\n            const before = lineText.slice(Math.max(0, cursor.ch - markerStart.length), cursor.ch);\r\n            const after = lineText.slice(cursor.ch, cursor.ch + markerEnd.length);\r\n            if ((markerStart && before && markerStart.startsWith(before) && before.length < markerStart.length && cursor.ch <= markerStart.length) ||\r\n                (markerEnd && after && markerEnd.endsWith(after) && after.length < markerEnd.length && cursor.ch >= lineText.length - markerEnd.length)) {\r\n                shouldCleanup = true;\r\n            }\r\n        }\r\n        if (shouldCleanup) {\r\n            if (this._cleanupGuard) return; // Prevent recursion/loops\r\n            this._cleanupGuard = true;\r\n            try {\r\n                this.toggleComment(editor);\r\n            } finally {\r\n                this._cleanupGuard = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        // Remove previously registered marker commands if force is true\r\n        if (force && this._markerCommandIds) {\r\n            // Do NOT remove commands dynamically; just clear our tracking array\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Main command: always present, always visible, always named 'Toggle Comment: (%%|%%)'\r\n        let mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n            // Do NOT normalize or change the template in settings\r\n            // mainTemplate = `${before} {cursor} ${after}`;\r\n            // this.settings.template = mainTemplate;\r\n            before = before;\r\n            after = after;\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Only register marker commands for marker sets that exist and are enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n    }\r\n\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n    }\r\n\r\n    insertComment(editor: Editor) {\r\n        let template = this.settings.template;\r\n        let cursorIndex = template.indexOf(\"{cursor}\");\r\n        if (cursorIndex === -1) {\r\n            // Fallback: insert template and move cursor to start\r\n            editor.replaceSelection(template);\r\n            return;\r\n        }\r\n        // Remove {cursor} and track where it was\r\n        let before = template.slice(0, cursorIndex).trim();\r\n        let after = template.slice(cursorIndex + \"{cursor}\".length).trim();\r\n        // Always add a space around the cursor\r\n        const commentText = `${before} ${after}`.replace(/\\s+/g, ' ').trim();\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(`${before}  ${after}`.replace(/\\s+/g, ' ').replace(' ', ' {cursor} '));\r\n        // Calculate the new cursor position\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length + 1; // +1 for the space\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Toggle comment using a specific marker set, or the default template if none provided.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n        // --- Clamp helper ---\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        let markerStart: string, markerEnd: string;\r\n        let markerStartNormalized: string, markerEndNormalized: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start.trim();\r\n            markerEnd = markerSet.end.trim();\r\n            markerStartNormalized = markerSet.start.endsWith(' ')? markerSet.start : markerSet.start + ' ';\r\n            markerEndNormalized = markerSet.end.startsWith(' ')? markerSet.end : ' ' + markerSet.end;\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before.trim();\r\n            markerEnd = after.trim();\r\n            // Always normalize for placement: ensure a space after start and before end\r\n            markerStartNormalized = markerStart + (markerStart && !markerStart.endsWith(' ')? ' ' : '');\r\n            markerEndNormalized = (markerEnd && !markerEnd.startsWith(' ')? ' ' : '') + markerEnd;\r\n        }\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let text: string;\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        let line = editor.getLine(cursor.line);\r\n        // Helper to find word bounds at a given ch, ignoring punctuation\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            // Only match sequences of letters, numbers, or underscores (ignore punctuation)\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        function isTextCommentedExact(str: string, start: string, end: string) {\r\n            if (!start) return false;\r\n            if (end) {\r\n                return str.startsWith(start) && str.endsWith(end);\r\n            } else {\r\n                return str.startsWith(start);\r\n            }\r\n        }\r\n        // Utility: Scan lines in a direction for a marker, stopping if the opposite marker is found first\r\n        function scanForFirst(lines: string[], fromLine: number, fromCh: number, marker: string, opposite: string, direction: 'back' | 'forward'): { type: 'marker' | 'opposite' | null, pos: { line: number, ch: number } | null } {\r\n            // Remove leading/trailing whitespace for marker matching\r\n            const markerTrim = marker.trim();\r\n            const oppositeTrim = opposite.trim();\r\n            if (direction === 'back') {\r\n                for (let l = fromLine; l >= 0; l--) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : line.length;\r\n                    for (let idx = searchStart - 1; idx >= 0; idx--) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            } else {\r\n                for (let l = fromLine; l < lines.length; l++) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : 0;\r\n                    for (let idx = searchStart; idx <= line.length - Math.min(markerTrim.length, oppositeTrim.length); idx++) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            }\r\n            return { type: null, pos: null };\r\n        }\r\n        // Main logic for comment detection\r\n        let isComment = false;\r\n        let commentStartPos: { line: number, ch: number } | null = null;\r\n        let commentEndPos: { line: number, ch: number } | null = null;\r\n        const allLines = editor.getValue().split('\\n');\r\n        if (markerStart && markerEnd) {\r\n            let beforeType, afterType;\r\n            if (selection) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            } else {\r\n                const before = scanForFirst(allLines, cursor.line, cursor.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, cursor.line, cursor.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            }\r\n            if (beforeType === 'marker' && afterType === 'marker') {\r\n                isComment = true;\r\n            } else if (beforeType === 'opposite' && afterType === 'opposite') {\r\n                isComment = false;\r\n            } else {\r\n                isComment = false;\r\n            }\r\n        }\r\n        // Log with 1-based line/ch for user clarity\r\n        logDev('comment:', isComment, {\r\n            start: commentStartPos ? { line: commentStartPos.line + 1, ch: commentStartPos.ch + 1 } : null,\r\n            end: commentEndPos ? { line: commentEndPos.line + 1, ch: commentEndPos.ch + 1 } : null\r\n        });\r\n\r\n        // --- Enhanced selection marker detection logic ---\r\n        if (selection && markerStart && markerEnd) {\r\n            const lineText = editor.getLine(from.line);\r\n            const selectionText = selection;\r\n            let foundStart = false, foundEnd = false;\r\n            let startIdx = selectionText.indexOf(markerStart);\r\n            let endIdx = selectionText.indexOf(markerEnd);\r\n            // Check if selection contains part of a marker\r\n            function containsPartOfMarker(sel: string, marker: string): boolean {\r\n                if (!marker) return false;\r\n                for (let i = 1; i <= marker.length; i++) {\r\n                    if (sel.includes(marker.slice(0, i)) || sel.includes(marker.slice(-i))) return true;\r\n                }\r\n                return false;\r\n            }\r\n            if (!foundStart && containsPartOfMarker(selectionText, markerStart)) {\r\n                // Check left and right of selection for full marker\r\n                const left = lineText.slice(Math.max(0, from.ch - markerStart.length), from.ch + selectionText.length);\r\n                if (left.includes(markerStart)) {\r\n                    foundStart = true;\r\n                    startIdx = left.indexOf(markerStart) - (from.ch - Math.max(0, from.ch - markerStart.length));\r\n                }\r\n            }\r\n            if (!foundEnd && containsPartOfMarker(selectionText, markerEnd)) {\r\n                const right = lineText.slice(from.ch, Math.min(lineText.length, to.ch + markerEnd.length));\r\n                if (right.includes(markerEnd)) {\r\n                    foundEnd = true;\r\n                    endIdx = right.indexOf(markerEnd);\r\n                }\r\n            }\r\n            if (selectionText.includes(markerStart)) {\r\n                foundStart = true;\r\n                startIdx = selectionText.indexOf(markerStart);\r\n            }\r\n            if (selectionText.includes(markerEnd)) {\r\n                foundEnd = true;\r\n                endIdx = selectionText.indexOf(markerEnd);\r\n            }\r\n            // If start/end markers are identical, search both directions\r\n            if (markerStart === markerEnd && markerStart.length > 0 && (foundStart || foundEnd)) {\r\n                // Search both directions for the other marker\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, '', 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, '', 'forward');\r\n                if (before.type === 'marker') commentStartPos = before.pos;\r\n                if (after.type === 'marker') commentEndPos = after.pos;\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            } else if (foundStart && !foundEnd) {\r\n                // Redundant search: search forward for end marker, stop if another start marker is found\r\n                let searchLine = from.line;\r\n                let searchCh = lineText.indexOf(markerStart, from.ch);\r\n                if (searchCh === -1) searchCh = from.ch;\r\n                let found = false;\r\n                for (let l = searchLine; l < allLines.length; l++) {\r\n                    let line = allLines[l];\r\n                    let start = (l === searchLine) ? searchCh + markerStart.length : 0;\r\n                    for (let idx = start; idx <= line.length - markerEnd.length; idx++) {\r\n                        if (line.substr(idx, markerEnd.length) === markerEnd) {\r\n                            commentStartPos = { line: searchLine, ch: searchCh };\r\n                            commentEndPos = { line: l, ch: idx };\r\n                            isComment = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                        if (line.substr(idx, markerStart.length) === markerStart && (l !== searchLine || idx !== searchCh)) {\r\n                            logDev('Stopped search for end marker: found another start marker first', { from: { line: searchLine, ch: searchCh }, at: { line: l, ch: idx } });\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (found) break;\r\n                }\r\n            } else if (foundEnd && !foundStart) {\r\n                // Redundant search: search backward for start marker, stop if another end marker is found\r\n                let searchLine = to.line;\r\n                let searchCh = lineText.indexOf(markerEnd, from.ch);\r\n                if (searchCh === -1) searchCh = to.ch;\r\n                let found = false;\r\n                for (let l = searchLine; l >= 0; l--) {\r\n                    let line = allLines[l];\r\n                    let end = (l === searchLine) ? searchCh - 1 : line.length - 1;\r\n                    for (let idx = end; idx >= 0; idx--) {\r\n                        if (line.substr(idx, markerStart.length) === markerStart) {\r\n                            commentStartPos = { line: l, ch: idx };\r\n                            commentEndPos = { line: searchLine, ch: searchCh };\r\n                            isComment = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                        if (line.substr(idx, markerEnd.length) === markerEnd && (l !== searchLine || idx !== searchCh)) {\r\n                            logDev('Stopped search for start marker: found another end marker first', { from: { line: searchLine, ch: searchCh }, at: { line: l, ch: idx } });\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (found) break;\r\n                }\r\n            }\r\n            // Only trigger marker removal if selection/cursor is at marker boundary\r\n            const atStartBoundary = from.ch <= markerStart.length && lineText.slice(0, markerStart.length).startsWith(markerStart);\r\n            const atEndBoundary = to.ch >= lineText.length - markerEnd.length && lineText.slice(-markerEnd.length).endsWith(markerEnd);\r\n            if (!atStartBoundary && !atEndBoundary) {\r\n                // Editing inside marker: do not remove or insert comment\r\n                return;\r\n            }\r\n        }\r\n\r\n        // --- Enhanced selection marker detection logic ---\r\n        if (selection && markerStart && markerEnd) {\r\n            const lineText = editor.getLine(from.line);\r\n            const selectionText = selection;\r\n            let foundStart = false, foundEnd = false;\r\n            let startIdx = selectionText.indexOf(markerStart);\r\n            let endIdx = selectionText.indexOf(markerEnd);\r\n            // Check if selection contains part of a marker\r\n            function containsPartOfMarker(sel: string, marker: string): boolean {\r\n                if (!marker) return false;\r\n                for (let i = 1; i <= marker.length; i++) {\r\n                    if (sel.includes(marker.slice(0, i)) || sel.includes(marker.slice(-i))) return true;\r\n                }\r\n                return false;\r\n            }\r\n            if (!foundStart && containsPartOfMarker(selectionText, markerStart)) {\r\n                // Check left and right of selection for full marker\r\n                const left = lineText.slice(Math.max(0, from.ch - markerStart.length), from.ch + selectionText.length);\r\n                if (left.includes(markerStart)) {\r\n                    foundStart = true;\r\n                    startIdx = left.indexOf(markerStart) - (from.ch - Math.max(0, from.ch - markerStart.length));\r\n                }\r\n            }\r\n            if (!foundEnd && containsPartOfMarker(selectionText, markerEnd)) {\r\n                const right = lineText.slice(from.ch, Math.min(lineText.length, to.ch + markerEnd.length));\r\n                if (right.includes(markerEnd)) {\r\n                    foundEnd = true;\r\n                    endIdx = right.indexOf(markerEnd);\r\n                }\r\n            }\r\n            if (selectionText.includes(markerStart)) {\r\n                foundStart = true;\r\n                startIdx = selectionText.indexOf(markerStart);\r\n            }\r\n            if (selectionText.includes(markerEnd)) {\r\n                foundEnd = true;\r\n                endIdx = selectionText.indexOf(markerEnd);\r\n            }\r\n            // If start/end markers are identical, search both directions\r\n            if (markerStart === markerEnd && markerStart.length > 0 && (foundStart || foundEnd)) {\r\n                // Search both directions for the other marker\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, '', 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, '', 'forward');\r\n                if (before.type === 'marker') commentStartPos = before.pos;\r\n                if (after.type === 'marker') commentEndPos = after.pos;\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            } else if (foundStart) {\r\n                // Search forward for end marker\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, markerStart, 'forward');\r\n                if (after.type === 'marker') commentEndPos = after.pos;\r\n                // Set start marker position\r\n                const startLineIdx = from.line;\r\n                const startChIdx = lineText.indexOf(markerStart, from.ch);\r\n                if (startChIdx !== -1) commentStartPos = { line: startLineIdx, ch: startChIdx };\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            } else if (foundEnd) {\r\n                // Search backward for start marker\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, markerEnd, 'back');\r\n                if (before.type === 'marker') commentStartPos = before.pos;\r\n                // Set end marker position\r\n                const endLineIdx = to.line;\r\n                const endChIdx = lineText.indexOf(markerEnd, from.ch);\r\n                if (endChIdx !== -1) commentEndPos = { line: endLineIdx, ch: endChIdx };\r\n                if (commentStartPos && commentEndPos) isComment = true;\r\n            }\r\n        }\r\n\r\n        if (isComment && commentStartPos && commentEndPos) {\r\n            // Remove start marker (marker + following space)\r\n            let startLine = allLines[commentStartPos.line];\r\n            const startMarkerWithSpace = markerStart + ' ';\r\n            allLines[commentStartPos.line] = startLine.slice(0, commentStartPos.ch) + startLine.slice(commentStartPos.ch + startMarkerWithSpace.length);\r\n            // Adjust end marker position if on same line as start\r\n            let endLineIdx = commentEndPos.line;\r\n            let endChIdx = commentEndPos.ch;\r\n            if (commentStartPos.line === commentEndPos.line) {\r\n                // Recalculate end marker position after start marker removal\r\n                endChIdx -= startMarkerWithSpace.length;\r\n                // Re-scan for the end marker after start marker removal\r\n                let updatedLine = allLines[endLineIdx];\r\n                const endMarkerWithSpace = ' ' + markerEnd;\r\n                endChIdx = updatedLine.indexOf(endMarkerWithSpace, endChIdx);\r\n                if (endChIdx === -1) {\r\n                    // fallback: try to find just the marker\r\n                    endChIdx = updatedLine.indexOf(markerEnd, endChIdx);\r\n                    if (endChIdx > 0 && updatedLine[endChIdx - 1] === ' ') {\r\n                        endChIdx = endChIdx - 1;\r\n                    }\r\n                }\r\n                if (endChIdx === -1) {\r\n                    // If still not found, skip end marker removal\r\n                    return;\r\n                }\r\n                // Remove end marker (preceding space + marker)\r\n                allLines[endLineIdx] = updatedLine.slice(0, endChIdx) + updatedLine.slice(endChIdx + endMarkerWithSpace.length);\r\n            } else {\r\n                // Remove end marker (preceding space + marker)\r\n                let endLine = allLines[endLineIdx];\r\n                const endMarkerWithSpace = ' ' + markerEnd;\r\n                allLines[endLineIdx] = endLine.slice(0, endChIdx) + endLine.slice(endChIdx + endMarkerWithSpace.length);\r\n            }\r\n            // Replace the affected lines in the editor\r\n            const fromLine = Math.min(commentStartPos.line, commentEndPos.line);\r\n            const toLine = Math.max(commentStartPos.line, commentEndPos.line);\r\n            const newText = allLines.slice(fromLine, toLine + 1).join('\\n');\r\n            editor.replaceRange(newText, { line: fromLine, ch: 0 }, { line: toLine, ch: editor.getLine(toLine).length });\r\n            // Adjust cursor position: keep it at the same logical place after removing start marker\r\n            let newCursorLine = from.line;\r\n            let newCursorCh = from.ch - startMarkerWithSpace.length;\r\n            if (newCursorCh < 0) newCursorCh = 0;\r\n            // If cursor would be outside the document, clamp to end\r\n            const lastLine = allLines.length - 1;\r\n            if (newCursorLine > lastLine) newCursorLine = lastLine;\r\n            let lineLen = allLines[newCursorLine]?.length ?? 0;\r\n            if (newCursorCh > lineLen) newCursorCh = lineLen;\r\n            // If the calculated line/ch is outside the document, set to very end\r\n            let clamped = clampCursorPos({ line: newCursorLine, ch: newCursorCh });\r\n            editor.setCursor(clamped);\r\n            return;\r\n        }\r\n\r\n        // Decide word or insert-at-cursor mode\r\n        let useWord = false;\r\n        wordBounds = getWordBounds(line, cursor.ch);\r\n        if (selection) {\r\n            useWord = false;\r\n        } else if (wordBounds) {\r\n            // Cursor is inside a word\r\n            if (cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                // Always operate on the word if cursor is inside the word (not at boundary)\r\n                useWord = true;\r\n            } else if (this.settings.wordOnlyMode && (cursor.ch === wordBounds.start || cursor.ch === wordBounds.end)) {\r\n                // Only operate on the word at boundary if wordOnlyMode is enabled\r\n                useWord = true;\r\n            } else {\r\n                // At word boundary and wordOnlyMode is off: insert at cursor\r\n                useWord = false;\r\n            }\r\n        }\r\n        logDev('Mode:', selection ? 'selection' : useWord ? 'word' : 'insert', { selection, wordBounds, useWord });\r\n        // Determine text and range\r\n        if (selection) {\r\n            text = selection;\r\n        } else if (useWord && wordBounds) {\r\n            text = line.slice(wordBounds.start, wordBounds.end);\r\n            from = { line: cursor.line, ch: wordBounds.start };\r\n            to = { line: cursor.line, ch: wordBounds.end };\r\n        } else {\r\n            text = '';\r\n            from = { line: cursor.line, ch: cursor.ch };\r\n            to = { line: cursor.line, ch: cursor.ch };\r\n        }\r\n        // Remove block comment logic (findBlockCommentBounds) as it is not needed for the new comment detection\r\n        // Check if selection or word/line is inside a comment (custom or default)\r\n        // --- Removal takes priority ---\r\n        let removalUsedStart = markerStart;\r\n        let removalUsedEnd = markerEnd;\r\n        let removalInside = false;\r\n        let removalCheckText = text;\r\n        if (selection) {\r\n            if (removalUsedStart && removalUsedEnd && selection.startsWith(removalUsedStart) && selection.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = selection;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && selection.startsWith(style.start) && selection.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = selection;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside) {\r\n                const lineStart = editor.getLine(from.line);\r\n                const lineEnd = editor.getLine(to.line);\r\n                if (removalUsedStart && removalUsedEnd && lineStart.startsWith(removalUsedStart) && lineEnd.endsWith(removalUsedEnd)) {\r\n                    removalInside = true;\r\n                    removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                } else {\r\n                    for (const style of defaultStyles) {\r\n                        if (style.start && style.end && lineStart.startsWith(style.start) && lineEnd.endsWith(style.end)) {\r\n                            removalUsedStart = style.start;\r\n                            removalUsedEnd = style.end;\r\n                            removalInside = true;\r\n                            removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (useWord && wordBounds) {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside && removalUsedStart && removalUsedEnd && text.startsWith(removalUsedStart) && text.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = text;\r\n            } else if (!removalInside) {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && text.startsWith(style.start) && text.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = text;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Remove the nearest comment markers before/after the word or selection\r\n        function removeNearestMarkersFromWordOrSelection(text: string, start: string, end: string, selectionStart: number, selectionEnd: number): { result: string, newStart: number, newEnd: number } {\r\n            return { result: text, newStart: selectionStart, newEnd: selectionEnd };\r\n        }\r\n        if (removalInside) {\r\n            // New logic: If user deletes the start marker and only spaces are between start and end marker, also delete the end marker\r\n            if (selection && removalUsedStart && removalCheckText === removalUsedStart) {\r\n                // Check if the text after the start marker up to the end marker is only whitespace\r\n                const lineText = editor.getLine(from.line);\r\n                const startIdx = lineText.indexOf(removalUsedStart);\r\n                const endIdx = removalUsedEnd ? lineText.indexOf(removalUsedEnd, startIdx + removalUsedStart.length) : -1;\r\n                if (endIdx !== -1) {\r\n                    const between = lineText.slice(startIdx + removalUsedStart.length, endIdx);\r\n                    if (/^\\s*$/.test(between)) {\r\n                        logDev('Deleting end marker after deleting start marker', { line: from.line, startIdx, endIdx, removalUsedStart, removalUsedEnd });\r\n                        // Remove both start and end marker\r\n                        const before = lineText.slice(0, startIdx);\r\n                        const after = lineText.slice(endIdx + removalUsedEnd.length);\r\n                        editor.setLine(from.line, before + after);\r\n                        // Set cursor to where the start marker was\r\n                        editor.setCursor({ line: from.line, ch: startIdx });\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            // No-op: skip marker removal entirely\r\n            return;\r\n        }\r\n        // Check if text/word/selection is commented\r\n        let usedStart = markerStart;\r\n        let usedEnd = markerEnd;\r\n        let inside = false;\r\n        let checkText = text;\r\n        if (selection) {\r\n            checkText = text;\r\n        } else if (useWord && wordBounds) {\r\n            checkText = line.slice(wordBounds.start, wordBounds.end);\r\n        } else {\r\n            checkText = text;\r\n        }\r\n        if (usedStart && isTextCommentedExact(checkText, usedStart, usedEnd)) {\r\n            inside = true;\r\n        } else {\r\n            for (const style of defaultStyles) {\r\n                if (style.start && isTextCommentedExact(checkText, style.start, style.end)) {\r\n                    usedStart = style.start;\r\n                    usedEnd = style.end;\r\n                    inside = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // --- Insertion/Removal logic ---\r\n        // Always insert: [start][space][text][space][end]\r\n        // Always remove: [start][space][text][space][end] (including spaces)\r\n        // Helper to build commented string\r\n        function buildCommented(text: string) {\r\n            return markerStart + ' ' + text + ' ' + markerEnd;\r\n        }\r\n        // Helper to match and remove full marker (with spaces)\r\n        function stripCommented(str: string) {\r\n            const start = markerStart + ' ';\r\n            const end = ' ' + markerEnd;\r\n            if (str.startsWith(start) && str.endsWith(end)) {\r\n                return str.slice(start.length, str.length - end.length);\r\n            }\r\n            // Try without spaces (legacy)\r\n            if (str.startsWith(markerStart) && str.endsWith(markerEnd)) {\r\n                return str.slice(markerStart.length, str.length - markerEnd.length).trim();\r\n            }\r\n            return null;\r\n        }\r\n        // ---\r\n        let uncommented = null;\r\n        if (selection) {\r\n            uncommented = stripCommented(text);\r\n            if (uncommented !== null) inside = true;\r\n        } else if (useWord && wordBounds) {\r\n            const wordText = line.slice(wordBounds.start, wordBounds.end);\r\n            uncommented = stripCommented(wordText);\r\n            if (uncommented !== null) inside = true;\r\n        } else {\r\n            uncommented = stripCommented(text);\r\n            if (uncommented !== null) inside = true;\r\n        }\r\n        if (inside) {\r\n            // Remove full marker (with spaces)\r\n            const safeUncommented = uncommented !== null ? uncommented : text;\r\n            if (selection) {\r\n                editor.replaceSelection(safeUncommented);\r\n                const selFrom = clampCursorPos(from);\r\n                const selTo = clampCursorPos({ line: to.line, ch: from.ch + safeUncommented.length });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(safeUncommented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = wordBounds.start + safeUncommented.length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                editor.replaceRange(safeUncommented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch });\r\n                editor.setCursor(clamped);\r\n            }\r\n        } else {\r\n            // Insert marker with spaces\r\n            let trimmedText = text.trim();\r\n            let commented: string;\r\n            if (!selection && !trimmedText) {\r\n                // No selection: insert two spaces between markers, cursor between them\r\n                commented = markerStart + '  ' + markerEnd;\r\n            } else {\r\n                commented = buildCommented(trimmedText);\r\n            }\r\n            if (!selection && !trimmedText) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                // Place cursor between the two spaces\r\n                const cursorPos = cursor.ch + (markerStart + ' ').length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursorPos });\r\n                editor.setCursor(clamped);\r\n            } else if (selection) {\r\n                editor.replaceSelection(commented);\r\n                const startOffset = (markerStart + ' ').length;\r\n                const selFrom = clampCursorPos({ line: from.line, ch: from.ch + startOffset });\r\n                const selTo = clampCursorPos({ line: to.line, ch: from.ch + startOffset + trimmedText.length });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = wordBounds.start + (markerStart + ' ').length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch + (markerStart + ' ').length });\r\n                editor.setCursor(clamped);\r\n            }\r\n        }\r\n        // After inserting, clamp cursor to end of document if needed\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            // Remove markers from the line\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "ubAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,aAAAE,IAAA,eAAAC,GAAAH,IAQA,IAAAI,GAA+B,oBCaxB,IAAMC,GAA0C,CACnD,SAAU,iBACV,aAAc,GACd,kBAAmB,CAAC,CACxB,ECjBA,IAAAC,EAA+C,oBAGlCC,EAAN,cAAsC,kBAAiB,CAG1D,YAAYC,EAAUC,EAA6B,CAC/C,MAAMD,EAAKC,CAAM,EACjB,KAAK,OAASA,CAClB,CAEA,SAAgB,CACZ,GAAM,CAAE,YAAAC,CAAY,EAAI,KACxBA,EAAY,MAAM,EAElB,IAAI,UAAQA,CAAW,EAClB,QAAQ,gBAAgB,EACxB,QAAQ,iGAAiG,EACzG,QAAQC,GACLA,EACK,SAAS,KAAK,OAAO,SAAS,QAAQ,EACtC,SAAS,MAAOC,GAAU,CACvB,KAAK,OAAO,SAAS,SAAWA,GAAS,iBACzC,MAAM,KAAK,OAAO,aAAa,CACnC,CAAC,CACT,EAEJ,IAAI,UAAQF,CAAW,EAClB,QAAQ,uBAAuB,EAC/B,QAAQ,gIAAgI,EACxI,UAAUG,GACPA,EACK,SAAS,CAAC,CAAC,KAAK,OAAO,SAAS,YAAY,EAC5C,SAAS,MAAOD,GAAU,CACvB,KAAK,OAAO,SAAS,aAAeA,EACpC,MAAM,KAAK,OAAO,aAAa,CACnC,CAAC,CACT,EAGJF,EAAY,SAAS,KAAM,CAAE,KAAM,wBAAyB,CAAC,GACnC,KAAK,OAAO,SAAS,mBAAqB,CAAC,GACnD,QAAQ,CAACI,EAAQC,IAAQ,CACvC,IAAMC,EAAU,IAAI,UAAQN,CAAW,EAClC,QAAQ,cAAcK,EAAM,CAAC,EAAE,EAE/B,UAAUF,GAAUA,EAChB,SAAS,CAAC,CAACC,EAAO,eAAe,EACjC,SAAS,MAAOF,GAAU,CACnB,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkBG,CAAG,EAAE,gBAAkBH,EAC9D,MAAM,KAAK,OAAO,aAAa,EAC/B,KAAK,OAAO,uBAAuB,EAAI,EACvC,KAAK,QAAQ,EAErB,CAAC,CACL,EACC,QAAQD,GAAQA,EACZ,eAAe,cAAc,EAC7B,SAASG,EAAO,KAAK,EACrB,SAAS,MAAOF,GAAU,CACnB,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkBG,CAAG,EAAE,MAAQH,EACpD,MAAM,KAAK,OAAO,aAAa,EAGvC,CAAC,CACL,EACC,QAAQD,GAAQA,EACZ,eAAe,YAAY,EAC3B,SAASG,EAAO,GAAG,EACnB,SAAS,MAAOF,GAAU,CACnB,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkBG,CAAG,EAAE,IAAMH,EAClD,MAAM,KAAK,OAAO,aAAa,EAGvC,CAAC,CACL,EACC,eAAeK,GAAOA,EAClB,QAAQ,OAAO,EACf,WAAW,mBAAmB,EAC9B,QAAQ,SAAY,CACb,KAAK,OAAO,SAAS,oBACrB,KAAK,OAAO,SAAS,kBAAkB,OAAOF,EAAK,CAAC,EACpD,MAAM,KAAK,OAAO,aAAa,EAC/B,KAAK,QAAQ,EAErB,CAAC,CACL,CACR,CAAC,EACD,IAAI,UAAQL,CAAW,EAClB,UAAUO,GAAOA,EACb,cAAc,gBAAgB,EAC9B,OAAO,EACP,QAAQ,SAAY,CACZ,KAAK,OAAO,SAAS,oBAAmB,KAAK,OAAO,SAAS,kBAAoB,CAAC,GACvF,KAAK,OAAO,SAAS,kBAAkB,KAAK,CAAE,MAAO,GAAI,IAAK,GAAI,gBAAiB,EAAM,CAAC,EAC1F,MAAM,KAAK,OAAO,aAAa,EAC/B,KAAK,QAAQ,CACjB,CAAC,CACL,CACR,CACJ,EF1FA,SAASC,KAAUC,EAAa,CAGxB,QAAQ,IAAI,sBAAuB,GAAGA,CAAI,CAElD,CAGA,IAAMC,EAAgB,CAClB,CAAE,MAAO,KAAM,IAAK,IAAK,EACzB,CAAE,MAAO,OAAQ,IAAK,KAAM,EAC5B,CAAE,MAAO,KAAM,IAAK,EAAG,CAC3B,EAEqBC,EAArB,cAAiD,SAAO,CAAxD,kCAKI,KAAQ,kBAA8B,CAAC,EACvC,KAAQ,cAAyB,GAEjC,MAAM,QAAS,CACX,MAAM,KAAK,aAAa,EACxB,KAAK,cAAc,IAAIC,EAAwB,KAAK,IAAK,IAAI,CAAC,EAG9D,KAAK,WAAW,CACZ,GAAI,yBACJ,KAAM,yBACN,SAAU,IAAM,KAAK,uBAAuB,EAAI,CACpD,CAAC,EAED,KAAK,uBAAuB,EAE5B,KAAK,cAAc,KAAK,IAAI,UAAU,GAAG,gBAAkBC,GAAmB,CACrEA,GAEDA,EAAO,UAAYA,EAAO,SAAS,GACnC,KAAK,mBAAmBA,CAAM,CAEtC,CAAC,CAAC,CACN,CAEA,mBAAmBA,EAAgB,CAE/B,IAAMC,EAAYD,EAAO,aAAa,EAChCE,EAASF,EAAO,UAAU,EAC1BG,EAAOH,EAAO,UAAU,MAAM,EAC9BI,EAAKJ,EAAO,UAAU,IAAI,EAC1BK,EAAWL,EAAO,QAAQE,EAAO,IAAI,EACrCI,EAAW,KAAK,SAAS,SACzBC,EAAcD,EAAS,QAAQ,UAAU,EAC3CE,EAAcF,EAAS,MAAM,EAAGC,CAAW,EAC3CE,EAAYH,EAAS,MAAMC,EAAc,CAAiB,EAG9D,SAASG,EAAmBC,EAAaC,EAAgBC,EAAcV,EAAcC,EAAqB,CACtG,GAAI,CAACQ,EAAQ,MAAO,GAIpB,GAFIT,GAAQ,GAAKA,GAAQS,EAAO,QAAUC,EAAK,MAAMV,EAAOS,EAAO,OAAQT,CAAI,IAAMS,GAEjFR,GAAM,GAAKA,GAAMS,EAAK,QAAUA,EAAK,MAAMT,EAAIA,EAAKQ,EAAO,MAAM,IAAMA,EAAQ,MAAO,GAE1F,GAAID,GAAOC,EAAO,OAAS,GACvB,QAASE,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IAC/B,GAAIH,EAAI,WAAWC,EAAO,MAAM,EAAGE,CAAC,CAAC,GAAKH,EAAI,SAASC,EAAO,MAAM,CAACE,CAAC,CAAC,EAAG,MAAO,GAGzF,MAAO,EACX,CAGA,IAAIC,EAAgB,GACpB,GAAId,EAEAc,EAAgBL,EAAmBT,EAAWO,EAAaH,EAAUF,EAAK,GAAIC,EAAG,EAAE,GACnEM,EAAmBT,EAAWQ,EAAWJ,EAAUF,EAAK,GAAIC,EAAG,EAAE,MAC9E,CAEH,IAAMY,EAASX,EAAS,MAAM,KAAK,IAAI,EAAGH,EAAO,GAAKM,EAAY,MAAM,EAAGN,EAAO,EAAE,EAC9Ee,EAAQZ,EAAS,MAAMH,EAAO,GAAIA,EAAO,GAAKO,EAAU,MAAM,GAC/DD,GAAeQ,GAAUR,EAAY,WAAWQ,CAAM,GAAKA,EAAO,OAASR,EAAY,QAAUN,EAAO,IAAMM,EAAY,QAC1HC,GAAaQ,GAASR,EAAU,SAASQ,CAAK,GAAKA,EAAM,OAASR,EAAU,QAAUP,EAAO,IAAMG,EAAS,OAASI,EAAU,UAChIM,EAAgB,GAExB,CACA,GAAIA,EAAe,CACf,GAAI,KAAK,cAAe,OACxB,KAAK,cAAgB,GACrB,GAAI,CACA,KAAK,cAAcf,CAAM,CAC7B,QAAE,CACE,KAAK,cAAgB,EACzB,CACJ,CACJ,CAKA,uBAAuBkB,EAAQ,GAAO,CAE9BA,GAAS,KAAK,oBAEd,KAAK,kBAAoB,CAAC,GAE9B,KAAK,kBAAoB,CAAC,EAG1B,IAAIC,EAAe,KAAK,SAAS,UAAY,iBACvCZ,EAAcY,EAAa,QAAQ,UAAU,EAC/CH,EAAS,KACTC,EAAQ,KACRV,IAAgB,KAChBS,EAASG,EAAa,MAAM,EAAGZ,CAAW,EAAE,KAAK,GAAK,KACtDU,EAAQE,EAAa,MAAMZ,EAAc,CAAiB,EAAE,KAAK,GAAK,KAItES,EAASA,EACTC,EAAQA,GAEZ,IAAMG,EAAS,0BACf,KAAK,WAAW,CACZ,GAAIA,EACJ,KAAM,oBAAoBJ,CAAM,IAAIC,CAAK,IACzC,eAAiBjB,GAAmB,KAAK,cAAcA,CAAM,CACjE,CAAC,EACD,KAAK,kBAAkB,KAAKoB,CAAM,EAG9B,MAAM,QAAQ,KAAK,SAAS,iBAAiB,GAC7C,KAAK,SAAS,kBAAkB,QAAQ,CAACR,EAAQE,IAAM,CACnD,GAAIF,GAAUA,EAAO,gBAAiB,CAClC,IAAMS,EAAK,6BAA6BP,EAAI,CAAC,GAC7C,KAAK,WAAW,CACZ,GAAAO,EACA,MAAO,IAAM,CACT,IAAMC,EAAQV,EAAO,OAAO,KAAK,GAAK,KAChCW,EAAMX,EAAO,KAAK,KAAK,GAAK,KAClC,MAAO,iBAAiBE,EAAI,CAAC,MAAMQ,CAAK,IAAIC,CAAG,GACnD,GAAG,EACH,cAAe,CAACC,EAAmBxB,KAC3B,CAACwB,GAAYxB,GAAQ,KAAK,cAAcA,EAAQY,CAAM,EACnD,GAEf,CAAC,EACD,KAAK,kBAAkB,KAAKS,CAAE,CAClC,CACJ,CAAC,CAET,CAEA,MAAM,cAAe,CACjB,KAAK,SAAW,OAAO,OAAO,CAAC,EAAGI,GAAkB,MAAM,KAAK,SAAS,CAAC,CAC7E,CAEA,MAAM,cAAe,CACjB,MAAM,KAAK,SAAS,KAAK,QAAQ,CACrC,CAMA,MAAM,cAAe,CAEjB,MAAM,KAAK,IAAI,QAAQ,cAAc,KAAK,SAAS,EAAE,EAErD,MAAM,KAAK,IAAI,QAAQ,aAAa,KAAK,SAAS,EAAE,CACxD,CAEA,cAAczB,EAAgB,CAC1B,IAAIM,EAAW,KAAK,SAAS,SACzBC,EAAcD,EAAS,QAAQ,UAAU,EAC7C,GAAIC,IAAgB,GAAI,CAEpBP,EAAO,iBAAiBM,CAAQ,EAChC,MACJ,CAEA,IAAIU,EAASV,EAAS,MAAM,EAAGC,CAAW,EAAE,KAAK,EAC7CU,EAAQX,EAAS,MAAMC,EAAc,CAAiB,EAAE,KAAK,EAE3DmB,EAAc,GAAGV,CAAM,IAAIC,CAAK,GAAG,QAAQ,OAAQ,GAAG,EAAE,KAAK,EAC7Dd,EAAOH,EAAO,UAAU,EAC9BA,EAAO,iBAAiB,GAAGgB,CAAM,KAAKC,CAAK,GAAG,QAAQ,OAAQ,GAAG,EAAE,QAAQ,IAAK,YAAY,CAAC,EAE7F,IAAMU,EAAQX,EAAO,MAAM;AAAA,CAAI,EACzBY,EAAmBD,EAAM,OAAS,EAClCE,EAAiBF,EAAMA,EAAM,OAAS,CAAC,EAAE,OAAS,EACxD3B,EAAO,UAAU,CACb,KAAMG,EAAK,KAAOyB,EAClB,IAAKA,EAAmB,EAAIzB,EAAK,IAAM0B,CAC3C,CAAC,CACL,CAOA,cAAc7B,EAAgB8B,EAA4C,CACtEnC,EAAO,uBAAwB,CAAE,UAAWK,EAAO,aAAa,EAAG,OAAQA,EAAO,UAAU,EAAG,UAAA8B,CAAU,CAAC,EAE1G,SAASC,EAAeC,EAAiE,CACrF,IAAMC,EAAWjC,EAAO,SAAS,EAAE,MAAM;AAAA,CAAI,EACzCa,EAAO,KAAK,IAAI,EAAG,KAAK,IAAImB,EAAI,KAAMC,EAAS,OAAS,CAAC,CAAC,EAC1DC,EAAK,KAAK,IAAI,EAAG,KAAK,IAAIF,EAAI,GAAIC,EAASpB,CAAI,GAAG,QAAU,CAAC,CAAC,EAClE,MAAO,CAAE,KAAAA,EAAM,GAAAqB,CAAG,CACtB,CACA,IAAI1B,EAAqBC,EACrB0B,EAA+BC,EACnC,GAAIN,EACAtB,EAAcsB,EAAU,MAAM,KAAK,EACnCrB,EAAYqB,EAAU,IAAI,KAAK,EAC/BK,EAAwBL,EAAU,MAAM,SAAS,GAAG,EAAGA,EAAU,MAAQA,EAAU,MAAQ,IAC3FM,EAAsBN,EAAU,IAAI,WAAW,GAAG,EAAGA,EAAU,IAAM,IAAMA,EAAU,QAClF,CACH,IAAMxB,EAAW,KAAK,SAAS,SACzBC,EAAcD,EAAS,QAAQ,UAAU,EAC3CU,EAASV,EACTW,EAAQ,GACRV,IAAgB,KAChBS,EAASV,EAAS,MAAM,EAAGC,CAAW,EACtCU,EAAQX,EAAS,MAAMC,EAAc,CAAiB,GAE1DC,EAAcQ,EAAO,KAAK,EAC1BP,EAAYQ,EAAM,KAAK,EAEvBkB,EAAwB3B,GAAeA,GAAe,CAACA,EAAY,SAAS,GAAG,EAAG,IAAM,IACxF4B,GAAuB3B,GAAa,CAACA,EAAU,WAAW,GAAG,EAAG,IAAM,IAAMA,CAChF,CACA,IAAMR,EAAYD,EAAO,aAAa,EAChCE,EAASF,EAAO,UAAU,EAC5BqC,EACAlC,EAAOH,EAAO,UAAU,MAAM,EAC9BI,EAAKJ,EAAO,UAAU,IAAI,EAC1BsC,EAAoD,KACpDzB,EAAOb,EAAO,QAAQE,EAAO,IAAI,EAErC,SAASqC,EAAc1B,EAAcqB,EAAmD,CAEpF,IAAMM,EAAQ,mBACVC,EACJ,MAAQA,EAAQD,EAAM,KAAK3B,CAAI,KAAO,MAClC,GAAIqB,GAAMO,EAAM,OAASP,GAAMO,EAAM,MAAQA,EAAM,CAAC,EAAE,OAClD,MAAO,CAAE,MAAOA,EAAM,MAAO,IAAKA,EAAM,MAAQA,EAAM,CAAC,EAAE,MAAO,EAGxE,OAAO,IACX,CACA,SAASC,EAAqBC,EAAarB,EAAeC,EAAa,CACnE,OAAKD,EACDC,EACOoB,EAAI,WAAWrB,CAAK,GAAKqB,EAAI,SAASpB,CAAG,EAEzCoB,EAAI,WAAWrB,CAAK,EAJZ,EAMvB,CAEA,SAASsB,EAAajB,EAAiBkB,EAAkBC,EAAgBlC,EAAgBmC,EAAkBC,EAAiH,CAExN,IAAMC,EAAarC,EAAO,KAAK,EACzBsC,EAAeH,EAAS,KAAK,EACnC,GAAIC,IAAc,OACd,QAASG,EAAIN,EAAUM,GAAK,EAAGA,IAAK,CAChC,IAAItC,EAAOc,EAAMwB,CAAC,EACdC,EAAcD,IAAMN,EAAWC,EAASjC,EAAK,OACjD,QAASwC,EAAMD,EAAc,EAAGC,GAAO,EAAGA,IAAO,CAC7C,GAAIxC,EAAK,OAAOwC,EAAKJ,EAAW,MAAM,IAAMA,EAAY,MAAO,CAAE,KAAM,SAAU,IAAK,CAAE,KAAME,EAAG,GAAIE,CAAI,CAAE,EAC3G,GAAIxC,EAAK,OAAOwC,EAAKH,EAAa,MAAM,IAAMA,EAAc,MAAO,CAAE,KAAM,WAAY,IAAK,CAAE,KAAMC,EAAG,GAAIE,CAAI,CAAE,CACrH,CACJ,KAEA,SAASF,EAAIN,EAAUM,EAAIxB,EAAM,OAAQwB,IAAK,CAC1C,IAAItC,EAAOc,EAAMwB,CAAC,EACdC,EAAcD,IAAMN,EAAWC,EAAS,EAC5C,QAASO,EAAMD,EAAaC,GAAOxC,EAAK,OAAS,KAAK,IAAIoC,EAAW,OAAQC,EAAa,MAAM,EAAGG,IAAO,CACtG,GAAIxC,EAAK,OAAOwC,EAAKJ,EAAW,MAAM,IAAMA,EAAY,MAAO,CAAE,KAAM,SAAU,IAAK,CAAE,KAAME,EAAG,GAAIE,CAAI,CAAE,EAC3G,GAAIxC,EAAK,OAAOwC,EAAKH,EAAa,MAAM,IAAMA,EAAc,MAAO,CAAE,KAAM,WAAY,IAAK,CAAE,KAAMC,EAAG,GAAIE,CAAI,CAAE,CACrH,CACJ,CAEJ,MAAO,CAAE,KAAM,KAAM,IAAK,IAAK,CACnC,CAEA,IAAIC,EAAY,GACZC,EAAuD,KACvDC,EAAqD,KACnDvB,EAAWjC,EAAO,SAAS,EAAE,MAAM;AAAA,CAAI,EAC7C,GAAIQ,GAAeC,EAAW,CAC1B,IAAIgD,EAAYC,EAChB,GAAIzD,EAAW,CACX,IAAMe,EAAS4B,EAAaX,EAAU9B,EAAK,KAAMA,EAAK,GAAIK,EAAaC,EAAW,MAAM,EAClFQ,EAAQ2B,EAAaX,EAAU7B,EAAG,KAAMA,EAAG,GAAIK,EAAWD,EAAa,SAAS,EACtFiD,EAAazC,EAAO,KACpB0C,EAAYzC,EAAM,KACdwC,IAAe,WAAUF,EAAkBvC,EAAO,KAClD0C,IAAc,WAAUF,EAAgBvC,EAAM,IACtD,KAAO,CACH,IAAMD,EAAS4B,EAAaX,EAAU/B,EAAO,KAAMA,EAAO,GAAIM,EAAaC,EAAW,MAAM,EACtFQ,EAAQ2B,EAAaX,EAAU/B,EAAO,KAAMA,EAAO,GAAIO,EAAWD,EAAa,SAAS,EAC9FiD,EAAazC,EAAO,KACpB0C,EAAYzC,EAAM,KACdwC,IAAe,WAAUF,EAAkBvC,EAAO,KAClD0C,IAAc,WAAUF,EAAgBvC,EAAM,IACtD,CACIwC,IAAe,UAAYC,IAAc,SACzCJ,EAAY,GAEZA,EAAY,EAIpB,CAQA,GANA3D,EAAO,WAAY2D,EAAW,CAC1B,MAAOC,EAAkB,CAAE,KAAMA,EAAgB,KAAO,EAAG,GAAIA,EAAgB,GAAK,CAAE,EAAI,KAC1F,IAAKC,EAAgB,CAAE,KAAMA,EAAc,KAAO,EAAG,GAAIA,EAAc,GAAK,CAAE,EAAI,IACtF,CAAC,EAGGvD,GAAaO,GAAeC,EAAW,CAOvC,IAASkD,EAAT,SAA8BhD,EAAaC,EAAyB,CAChE,GAAI,CAACA,EAAQ,MAAO,GACpB,QAASE,EAAI,EAAGA,GAAKF,EAAO,OAAQE,IAChC,GAAIH,EAAI,SAASC,EAAO,MAAM,EAAGE,CAAC,CAAC,GAAKH,EAAI,SAASC,EAAO,MAAM,CAACE,CAAC,CAAC,EAAG,MAAO,GAEnF,MAAO,EACX,EANS,IAAA6C,KANT,IAAMtD,EAAWL,EAAO,QAAQG,EAAK,IAAI,EACnCyD,EAAgB3D,EAClB4D,EAAa,GAAOC,EAAW,GAC/BC,EAAWH,EAAc,QAAQpD,CAAW,EAC5CwD,EAASJ,EAAc,QAAQnD,CAAS,EAS5C,GAAI,CAACoD,GAAcF,EAAqBC,EAAepD,CAAW,EAAG,CAEjE,IAAMyD,EAAO5D,EAAS,MAAM,KAAK,IAAI,EAAGF,EAAK,GAAKK,EAAY,MAAM,EAAGL,EAAK,GAAKyD,EAAc,MAAM,EACjGK,EAAK,SAASzD,CAAW,IACzBqD,EAAa,GACbE,EAAWE,EAAK,QAAQzD,CAAW,GAAKL,EAAK,GAAK,KAAK,IAAI,EAAGA,EAAK,GAAKK,EAAY,MAAM,GAElG,CACA,GAAI,CAACsD,GAAYH,EAAqBC,EAAenD,CAAS,EAAG,CAC7D,IAAMyD,EAAQ7D,EAAS,MAAMF,EAAK,GAAI,KAAK,IAAIE,EAAS,OAAQD,EAAG,GAAKK,EAAU,MAAM,CAAC,EACrFyD,EAAM,SAASzD,CAAS,IACxBqD,EAAW,GACXE,EAASE,EAAM,QAAQzD,CAAS,EAExC,CAUA,GATImD,EAAc,SAASpD,CAAW,IAClCqD,EAAa,GACbE,EAAWH,EAAc,QAAQpD,CAAW,GAE5CoD,EAAc,SAASnD,CAAS,IAChCqD,EAAW,GACXE,EAASJ,EAAc,QAAQnD,CAAS,GAGxCD,IAAgBC,GAAaD,EAAY,OAAS,IAAMqD,GAAcC,GAAW,CAEjF,IAAM9C,EAAS4B,EAAaX,EAAU9B,EAAK,KAAMA,EAAK,GAAIK,EAAa,GAAI,MAAM,EAC3ES,EAAQ2B,EAAaX,EAAU7B,EAAG,KAAMA,EAAG,GAAIK,EAAW,GAAI,SAAS,EACzEO,EAAO,OAAS,WAAUuC,EAAkBvC,EAAO,KACnDC,EAAM,OAAS,WAAUuC,EAAgBvC,EAAM,KAC/CsC,GAAmBC,IAAeF,EAAY,GACtD,SAAWO,GAAc,CAACC,EAAU,CAEhC,IAAIK,EAAahE,EAAK,KAClBiE,EAAW/D,EAAS,QAAQG,EAAaL,EAAK,EAAE,EAChDiE,IAAa,KAAIA,EAAWjE,EAAK,IACrC,IAAIkE,EAAQ,GACZ,QAASlB,EAAIgB,EAAYhB,EAAIlB,EAAS,OAAQkB,IAAK,CAC/C,IAAItC,EAAOoB,EAASkB,CAAC,EACjB7B,GAAS6B,IAAMgB,EAAcC,EAAW5D,EAAY,OAAS,EACjE,QAAS6C,EAAM/B,GAAO+B,GAAOxC,EAAK,OAASJ,EAAU,OAAQ4C,IAAO,CAChE,GAAIxC,EAAK,OAAOwC,EAAK5C,EAAU,MAAM,IAAMA,EAAW,CAClD8C,EAAkB,CAAE,KAAMY,EAAY,GAAIC,CAAS,EACnDZ,EAAgB,CAAE,KAAML,EAAG,GAAIE,CAAI,EACnCC,EAAY,GACZe,EAAQ,GACR,KACJ,CACA,GAAIxD,EAAK,OAAOwC,EAAK7C,EAAY,MAAM,IAAMA,IAAgB2C,IAAMgB,GAAcd,IAAQe,GAAW,CAChGzE,EAAO,kEAAmE,CAAE,KAAM,CAAE,KAAMwE,EAAY,GAAIC,CAAS,EAAG,GAAI,CAAE,KAAMjB,EAAG,GAAIE,CAAI,CAAE,CAAC,EAChJgB,EAAQ,GACR,KACJ,CACJ,CACA,GAAIA,EAAO,KACf,CACJ,SAAWP,GAAY,CAACD,EAAY,CAEhC,IAAIM,EAAa/D,EAAG,KAChBgE,EAAW/D,EAAS,QAAQI,EAAWN,EAAK,EAAE,EAC9CiE,IAAa,KAAIA,EAAWhE,EAAG,IACnC,IAAIiE,EAAQ,GACZ,QAASlB,EAAIgB,EAAYhB,GAAK,EAAGA,IAAK,CAClC,IAAItC,EAAOoB,EAASkB,CAAC,EACjB5B,GAAO4B,IAAMgB,EAAcC,EAAW,EAAIvD,EAAK,OAAS,EAC5D,QAASwC,EAAM9B,GAAK8B,GAAO,EAAGA,IAAO,CACjC,GAAIxC,EAAK,OAAOwC,EAAK7C,EAAY,MAAM,IAAMA,EAAa,CACtD+C,EAAkB,CAAE,KAAMJ,EAAG,GAAIE,CAAI,EACrCG,EAAgB,CAAE,KAAMW,EAAY,GAAIC,CAAS,EACjDd,EAAY,GACZe,EAAQ,GACR,KACJ,CACA,GAAIxD,EAAK,OAAOwC,EAAK5C,EAAU,MAAM,IAAMA,IAAc0C,IAAMgB,GAAcd,IAAQe,GAAW,CAC5FzE,EAAO,kEAAmE,CAAE,KAAM,CAAE,KAAMwE,EAAY,GAAIC,CAAS,EAAG,GAAI,CAAE,KAAMjB,EAAG,GAAIE,CAAI,CAAE,CAAC,EAChJgB,EAAQ,GACR,KACJ,CACJ,CACA,GAAIA,EAAO,KACf,CACJ,CAEA,IAAMC,EAAkBnE,EAAK,IAAMK,EAAY,QAAUH,EAAS,MAAM,EAAGG,EAAY,MAAM,EAAE,WAAWA,CAAW,EAC/G+D,EAAgBnE,EAAG,IAAMC,EAAS,OAASI,EAAU,QAAUJ,EAAS,MAAM,CAACI,EAAU,MAAM,EAAE,SAASA,CAAS,EACzH,GAAI,CAAC6D,GAAmB,CAACC,EAErB,MAER,CAGA,GAAItE,GAAaO,GAAeC,EAAW,CAOvC,IAASkD,EAAT,SAA8BhD,EAAaC,EAAyB,CAChE,GAAI,CAACA,EAAQ,MAAO,GACpB,QAASE,EAAI,EAAGA,GAAKF,EAAO,OAAQE,IAChC,GAAIH,EAAI,SAASC,EAAO,MAAM,EAAGE,CAAC,CAAC,GAAKH,EAAI,SAASC,EAAO,MAAM,CAACE,CAAC,CAAC,EAAG,MAAO,GAEnF,MAAO,EACX,EANS,IAAA6C,KANT,IAAMtD,EAAWL,EAAO,QAAQG,EAAK,IAAI,EACnCyD,EAAgB3D,EAClB4D,EAAa,GAAOC,EAAW,GAC/BC,EAAWH,EAAc,QAAQpD,CAAW,EAC5CwD,EAASJ,EAAc,QAAQnD,CAAS,EAS5C,GAAI,CAACoD,GAAcF,EAAqBC,EAAepD,CAAW,EAAG,CAEjE,IAAMyD,EAAO5D,EAAS,MAAM,KAAK,IAAI,EAAGF,EAAK,GAAKK,EAAY,MAAM,EAAGL,EAAK,GAAKyD,EAAc,MAAM,EACjGK,EAAK,SAASzD,CAAW,IACzBqD,EAAa,GACbE,EAAWE,EAAK,QAAQzD,CAAW,GAAKL,EAAK,GAAK,KAAK,IAAI,EAAGA,EAAK,GAAKK,EAAY,MAAM,GAElG,CACA,GAAI,CAACsD,GAAYH,EAAqBC,EAAenD,CAAS,EAAG,CAC7D,IAAMyD,EAAQ7D,EAAS,MAAMF,EAAK,GAAI,KAAK,IAAIE,EAAS,OAAQD,EAAG,GAAKK,EAAU,MAAM,CAAC,EACrFyD,EAAM,SAASzD,CAAS,IACxBqD,EAAW,GACXE,EAASE,EAAM,QAAQzD,CAAS,EAExC,CAUA,GATImD,EAAc,SAASpD,CAAW,IAClCqD,EAAa,GACbE,EAAWH,EAAc,QAAQpD,CAAW,GAE5CoD,EAAc,SAASnD,CAAS,IAChCqD,EAAW,GACXE,EAASJ,EAAc,QAAQnD,CAAS,GAGxCD,IAAgBC,GAAaD,EAAY,OAAS,IAAMqD,GAAcC,GAAW,CAEjF,IAAM9C,EAAS4B,EAAaX,EAAU9B,EAAK,KAAMA,EAAK,GAAIK,EAAa,GAAI,MAAM,EAC3ES,EAAQ2B,EAAaX,EAAU7B,EAAG,KAAMA,EAAG,GAAIK,EAAW,GAAI,SAAS,EACzEO,EAAO,OAAS,WAAUuC,EAAkBvC,EAAO,KACnDC,EAAM,OAAS,WAAUuC,EAAgBvC,EAAM,KAC/CsC,GAAmBC,IAAeF,EAAY,GACtD,SAAWO,EAAY,CAEnB,IAAM5C,EAAQ2B,EAAaX,EAAU7B,EAAG,KAAMA,EAAG,GAAIK,EAAWD,EAAa,SAAS,EAClFS,EAAM,OAAS,WAAUuC,EAAgBvC,EAAM,KAEnD,IAAMuD,EAAerE,EAAK,KACpBsE,EAAapE,EAAS,QAAQG,EAAaL,EAAK,EAAE,EACpDsE,IAAe,KAAIlB,EAAkB,CAAE,KAAMiB,EAAc,GAAIC,CAAW,GAC1ElB,GAAmBC,IAAeF,EAAY,GACtD,SAAWQ,EAAU,CAEjB,IAAM9C,EAAS4B,EAAaX,EAAU9B,EAAK,KAAMA,EAAK,GAAIK,EAAaC,EAAW,MAAM,EACpFO,EAAO,OAAS,WAAUuC,EAAkBvC,EAAO,KAEvD,IAAM0D,EAAatE,EAAG,KAChBuE,EAAWtE,EAAS,QAAQI,EAAWN,EAAK,EAAE,EAChDwE,IAAa,KAAInB,EAAgB,CAAE,KAAMkB,EAAY,GAAIC,CAAS,GAClEpB,GAAmBC,IAAeF,EAAY,GACtD,CACJ,CAEA,GAAIA,GAAaC,GAAmBC,EAAe,CAE/C,IAAIoB,EAAY3C,EAASsB,EAAgB,IAAI,EACvCsB,EAAuBrE,EAAc,IAC3CyB,EAASsB,EAAgB,IAAI,EAAIqB,EAAU,MAAM,EAAGrB,EAAgB,EAAE,EAAIqB,EAAU,MAAMrB,EAAgB,GAAKsB,EAAqB,MAAM,EAE1I,IAAIH,EAAalB,EAAc,KAC3BmB,EAAWnB,EAAc,GAC7B,GAAID,EAAgB,OAASC,EAAc,KAAM,CAE7CmB,GAAYE,EAAqB,OAEjC,IAAIC,EAAc7C,EAASyC,CAAU,EAC/BK,EAAqB,IAAMtE,EASjC,GARAkE,EAAWG,EAAY,QAAQC,EAAoBJ,CAAQ,EACvDA,IAAa,KAEbA,EAAWG,EAAY,QAAQrE,EAAWkE,CAAQ,EAC9CA,EAAW,GAAKG,EAAYH,EAAW,CAAC,IAAM,MAC9CA,EAAWA,EAAW,IAG1BA,IAAa,GAEb,OAGJ1C,EAASyC,CAAU,EAAII,EAAY,MAAM,EAAGH,CAAQ,EAAIG,EAAY,MAAMH,EAAWI,EAAmB,MAAM,CAClH,KAAO,CAEH,IAAIC,EAAU/C,EAASyC,CAAU,EAC3BK,EAAqB,IAAMtE,EACjCwB,EAASyC,CAAU,EAAIM,EAAQ,MAAM,EAAGL,CAAQ,EAAIK,EAAQ,MAAML,EAAWI,EAAmB,MAAM,CAC1G,CAEA,IAAMlC,EAAW,KAAK,IAAIU,EAAgB,KAAMC,EAAc,IAAI,EAC5DyB,EAAS,KAAK,IAAI1B,EAAgB,KAAMC,EAAc,IAAI,EAC1D0B,EAAUjD,EAAS,MAAMY,EAAUoC,EAAS,CAAC,EAAE,KAAK;AAAA,CAAI,EAC9DjF,EAAO,aAAakF,EAAS,CAAE,KAAMrC,EAAU,GAAI,CAAE,EAAG,CAAE,KAAMoC,EAAQ,GAAIjF,EAAO,QAAQiF,CAAM,EAAE,MAAO,CAAC,EAE3G,IAAIE,EAAgBhF,EAAK,KACrBiF,EAAcjF,EAAK,GAAK0E,EAAqB,OAC7CO,EAAc,IAAGA,EAAc,GAEnC,IAAMC,EAAWpD,EAAS,OAAS,EAC/BkD,EAAgBE,IAAUF,EAAgBE,GAC9C,IAAIC,EAAUrD,EAASkD,CAAa,GAAG,QAAU,EAC7CC,EAAcE,IAASF,EAAcE,GAEzC,IAAIC,EAAUxD,EAAe,CAAE,KAAMoD,EAAe,GAAIC,CAAY,CAAC,EACrEpF,EAAO,UAAUuF,CAAO,EACxB,MACJ,CAGA,IAAIC,EAAU,GACdlD,EAAaC,EAAc1B,EAAMX,EAAO,EAAE,EACtCD,EACAuF,EAAU,GACHlD,IAEHpC,EAAO,GAAKoC,EAAW,OAASpC,EAAO,GAAKoC,EAAW,KAGhD,KAAK,SAAS,eAAiBpC,EAAO,KAAOoC,EAAW,OAASpC,EAAO,KAAOoC,EAAW,KADjGkD,EAAU,GAMVA,EAAU,IAGlB7F,EAAO,QAASM,EAAY,YAAcuF,EAAU,OAAS,SAAU,CAAE,UAAAvF,EAAW,WAAAqC,EAAY,QAAAkD,CAAQ,CAAC,EAErGvF,EACAoC,EAAOpC,EACAuF,GAAWlD,GAClBD,EAAOxB,EAAK,MAAMyB,EAAW,MAAOA,EAAW,GAAG,EAClDnC,EAAO,CAAE,KAAMD,EAAO,KAAM,GAAIoC,EAAW,KAAM,EACjDlC,EAAK,CAAE,KAAMF,EAAO,KAAM,GAAIoC,EAAW,GAAI,IAE7CD,EAAO,GACPlC,EAAO,CAAE,KAAMD,EAAO,KAAM,GAAIA,EAAO,EAAG,EAC1CE,EAAK,CAAE,KAAMF,EAAO,KAAM,GAAIA,EAAO,EAAG,GAK5C,IAAIuF,EAAmBjF,EACnBkF,EAAiBjF,EACjBkF,EAAgB,GAChBC,EAAmBvD,EACvB,GAAIpC,EAAW,CACX,GAAIwF,GAAoBC,GAAkBzF,EAAU,WAAWwF,CAAgB,GAAKxF,EAAU,SAASyF,CAAc,EACjHC,EAAgB,GAChBC,EAAmB3F,MAEnB,SAAW4F,KAAShG,EAChB,GAAIgG,EAAM,OAASA,EAAM,KAAO5F,EAAU,WAAW4F,EAAM,KAAK,GAAK5F,EAAU,SAAS4F,EAAM,GAAG,EAAG,CAChGJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmB3F,EACnB,KACJ,CAGR,GAAI,CAAC0F,EAAe,CAChB,IAAMG,EAAY9F,EAAO,QAAQG,EAAK,IAAI,EACpC4F,EAAU/F,EAAO,QAAQI,EAAG,IAAI,EACtC,GAAIqF,GAAoBC,GAAkBI,EAAU,WAAWL,CAAgB,GAAKM,EAAQ,SAASL,CAAc,EAC/GC,EAAgB,GAChBC,EAAmB5F,EAAO,SAAS,CAAE,KAAMG,EAAK,KAAM,GAAI,CAAE,EAAG,CAAE,KAAMC,EAAG,KAAM,GAAIJ,EAAO,QAAQI,EAAG,IAAI,EAAE,MAAO,CAAC,MAEpH,SAAWyF,KAAShG,EAChB,GAAIgG,EAAM,OAASA,EAAM,KAAOC,EAAU,WAAWD,EAAM,KAAK,GAAKE,EAAQ,SAASF,EAAM,GAAG,EAAG,CAC9FJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmB5F,EAAO,SAAS,CAAE,KAAMG,EAAK,KAAM,GAAI,CAAE,EAAG,CAAE,KAAMC,EAAG,KAAM,GAAIJ,EAAO,QAAQI,EAAG,IAAI,EAAE,MAAO,CAAC,EACpH,KACJ,CAGZ,CACJ,SAAWoF,GAAWlD,EAAY,CAC9B,GAAImD,GAAoBC,GAAkB7E,EAAK,WAAW4E,CAAgB,GAAK5E,EAAK,SAAS6E,CAAc,EACvGC,EAAgB,GAChBC,EAAmB/E,MAEnB,SAAWgF,KAAShG,EAChB,GAAIgG,EAAM,OAASA,EAAM,KAAOhF,EAAK,WAAWgF,EAAM,KAAK,GAAKhF,EAAK,SAASgF,EAAM,GAAG,EAAG,CACtFJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmB/E,EACnB,KACJ,CAGR,GAAI,CAAC8E,GAAiBF,GAAoBC,GAAkBrD,EAAK,WAAWoD,CAAgB,GAAKpD,EAAK,SAASqD,CAAc,EACzHC,EAAgB,GAChBC,EAAmBvD,UACZ,CAACsD,GACR,QAAWE,KAAShG,EAChB,GAAIgG,EAAM,OAASA,EAAM,KAAOxD,EAAK,WAAWwD,EAAM,KAAK,GAAKxD,EAAK,SAASwD,EAAM,GAAG,EAAG,CACtFJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmBvD,EACnB,KACJ,EAGZ,SACQoD,GAAoBC,GAAkB7E,EAAK,WAAW4E,CAAgB,GAAK5E,EAAK,SAAS6E,CAAc,EACvGC,EAAgB,GAChBC,EAAmB/E,MAEnB,SAAWgF,KAAShG,EAChB,GAAIgG,EAAM,OAASA,EAAM,KAAOhF,EAAK,WAAWgF,EAAM,KAAK,GAAKhF,EAAK,SAASgF,EAAM,GAAG,EAAG,CACtFJ,EAAmBI,EAAM,MACzBH,EAAiBG,EAAM,IACvBF,EAAgB,GAChBC,EAAmB/E,EACnB,KACJ,CAKZ,SAASmF,GAAwC3D,EAAcf,EAAeC,EAAa0E,EAAwBC,EAA4E,CAC3L,MAAO,CAAE,OAAQ7D,EAAM,SAAU4D,EAAgB,OAAQC,CAAa,CAC1E,CACA,GAAIP,EAAe,CAEf,GAAI1F,GAAawF,GAAoBG,IAAqBH,EAAkB,CAExE,IAAMpF,EAAWL,EAAO,QAAQG,EAAK,IAAI,EACnC4D,EAAW1D,EAAS,QAAQoF,CAAgB,EAC5CzB,EAAS0B,EAAiBrF,EAAS,QAAQqF,EAAgB3B,EAAW0B,EAAiB,MAAM,EAAI,GACvG,GAAIzB,IAAW,GAAI,CACf,IAAMmC,EAAU9F,EAAS,MAAM0D,EAAW0B,EAAiB,OAAQzB,CAAM,EACzE,GAAI,QAAQ,KAAKmC,CAAO,EAAG,CACvBxG,EAAO,kDAAmD,CAAE,KAAMQ,EAAK,KAAM,SAAA4D,EAAU,OAAAC,EAAQ,iBAAAyB,EAAkB,eAAAC,CAAe,CAAC,EAEjI,IAAM1E,EAASX,EAAS,MAAM,EAAG0D,CAAQ,EACnC9C,EAAQZ,EAAS,MAAM2D,EAAS0B,EAAe,MAAM,EAC3D1F,EAAO,QAAQG,EAAK,KAAMa,EAASC,CAAK,EAExCjB,EAAO,UAAU,CAAE,KAAMG,EAAK,KAAM,GAAI4D,CAAS,CAAC,EAClD,MACJ,CACJ,CACJ,CAEA,MACJ,CAEA,IAAIqC,EAAY5F,EACZ6F,GAAU5F,EACV6F,EAAS,GACTC,EAAYlE,EAQhB,GAPIpC,EACAsG,EAAYlE,EACLmD,GAAWlD,EAClBiE,EAAY1F,EAAK,MAAMyB,EAAW,MAAOA,EAAW,GAAG,EAEvDiE,EAAYlE,EAEZ+D,GAAa1D,EAAqB6D,EAAWH,EAAWC,EAAO,EAC/DC,EAAS,OAET,SAAWT,KAAShG,EAChB,GAAIgG,EAAM,OAASnD,EAAqB6D,EAAWV,EAAM,MAAOA,EAAM,GAAG,EAAG,CACxEO,EAAYP,EAAM,MAClBQ,GAAUR,EAAM,IAChBS,EAAS,GACT,KACJ,CAOR,SAASE,GAAenE,EAAc,CAClC,OAAO7B,EAAc,IAAM6B,EAAO,IAAM5B,CAC5C,CAEA,SAASgG,EAAe9D,EAAa,CACjC,IAAMrB,EAAQd,EAAc,IACtBe,EAAM,IAAMd,EAClB,OAAIkC,EAAI,WAAWrB,CAAK,GAAKqB,EAAI,SAASpB,CAAG,EAClCoB,EAAI,MAAMrB,EAAM,OAAQqB,EAAI,OAASpB,EAAI,MAAM,EAGtDoB,EAAI,WAAWnC,CAAW,GAAKmC,EAAI,SAASlC,CAAS,EAC9CkC,EAAI,MAAMnC,EAAY,OAAQmC,EAAI,OAASlC,EAAU,MAAM,EAAE,KAAK,EAEtE,IACX,CAEA,IAAIiG,EAAc,KAClB,GAAIzG,EACAyG,EAAcD,EAAepE,CAAI,EAC7BqE,IAAgB,OAAMJ,EAAS,YAC5Bd,GAAWlD,EAAY,CAC9B,IAAMqE,EAAW9F,EAAK,MAAMyB,EAAW,MAAOA,EAAW,GAAG,EAC5DoE,EAAcD,EAAeE,CAAQ,EACjCD,IAAgB,OAAMJ,EAAS,GACvC,MACII,EAAcD,EAAepE,CAAI,EAC7BqE,IAAgB,OAAMJ,EAAS,IAEvC,GAAIA,EAAQ,CAER,IAAMM,EAAkBF,IAAgB,KAAOA,EAAcrE,EAC7D,GAAIpC,EAAW,CACXD,EAAO,iBAAiB4G,CAAe,EACvC,IAAMC,EAAU9E,EAAe5B,CAAI,EAC7B2G,EAAQ/E,EAAe,CAAE,KAAM3B,EAAG,KAAM,GAAID,EAAK,GAAKyG,EAAgB,MAAO,CAAC,EACpF5G,EAAO,aAAa6G,EAASC,CAAK,CACtC,SAAWtB,GAAWlD,EAAY,CAC9BtC,EAAO,aAAa4G,EAAiB,CAAE,KAAM1G,EAAO,KAAM,GAAIoC,EAAW,KAAM,EAAG,CAAE,KAAMpC,EAAO,KAAM,GAAIoC,EAAW,GAAI,CAAC,EAC3H,IAAMyE,EAAQzE,EAAW,MAAQsE,EAAgB,OAC3CrB,EAAUxD,EAAe,CAAE,KAAM7B,EAAO,KAAM,GAAI6G,CAAM,CAAC,EAC/D/G,EAAO,UAAUuF,CAAO,CAC5B,KAAO,CACHvF,EAAO,aAAa4G,EAAiB,CAAE,KAAM1G,EAAO,KAAM,GAAIA,EAAO,EAAG,EAAG,CAAE,KAAMA,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EAC/G,IAAMqF,EAAUxD,EAAe,CAAE,KAAM7B,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EACnEF,EAAO,UAAUuF,CAAO,CAC5B,CACJ,KAAO,CAEH,IAAIyB,EAAc3E,EAAK,KAAK,EACxB4E,EAOJ,GANI,CAAChH,GAAa,CAAC+G,EAEfC,EAAYzG,EAAc,KAAOC,EAEjCwG,EAAYT,GAAeQ,CAAW,EAEtC,CAAC/G,GAAa,CAAC+G,EAAa,CAC5BhH,EAAO,aAAaiH,EAAW,CAAE,KAAM/G,EAAO,KAAM,GAAIA,EAAO,EAAG,EAAG,CAAE,KAAMA,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EAEzG,IAAMgH,EAAYhH,EAAO,IAAMM,EAAc,KAAK,OAC5C+E,EAAUxD,EAAe,CAAE,KAAM7B,EAAO,KAAM,GAAIgH,CAAU,CAAC,EACnElH,EAAO,UAAUuF,CAAO,CAC5B,SAAWtF,EAAW,CAClBD,EAAO,iBAAiBiH,CAAS,EACjC,IAAME,GAAe3G,EAAc,KAAK,OAClCqG,EAAU9E,EAAe,CAAE,KAAM5B,EAAK,KAAM,GAAIA,EAAK,GAAKgH,CAAY,CAAC,EACvEL,EAAQ/E,EAAe,CAAE,KAAM3B,EAAG,KAAM,GAAID,EAAK,GAAKgH,EAAcH,EAAY,MAAO,CAAC,EAC9FhH,EAAO,aAAa6G,EAASC,CAAK,CACtC,SAAWtB,GAAWlD,EAAY,CAC9BtC,EAAO,aAAaiH,EAAW,CAAE,KAAM/G,EAAO,KAAM,GAAIoC,EAAW,KAAM,EAAG,CAAE,KAAMpC,EAAO,KAAM,GAAIoC,EAAW,GAAI,CAAC,EACrH,IAAMyE,EAAQzE,EAAW,OAAS9B,EAAc,KAAK,OAC/C+E,EAAUxD,EAAe,CAAE,KAAM7B,EAAO,KAAM,GAAI6G,CAAM,CAAC,EAC/D/G,EAAO,UAAUuF,CAAO,CAC5B,KAAO,CACHvF,EAAO,aAAaiH,EAAW,CAAE,KAAM/G,EAAO,KAAM,GAAIA,EAAO,EAAG,EAAG,CAAE,KAAMA,EAAO,KAAM,GAAIA,EAAO,EAAG,CAAC,EACzG,IAAMqF,EAAUxD,EAAe,CAAE,KAAM7B,EAAO,KAAM,GAAIA,EAAO,IAAMM,EAAc,KAAK,MAAO,CAAC,EAChGR,EAAO,UAAUuF,CAAO,CAC5B,CACJ,CAEA,IAAM6B,EAAcrF,EAAe/B,EAAO,UAAU,CAAC,GACjDoH,EAAY,OAASpH,EAAO,UAAU,EAAE,MAAQoH,EAAY,KAAOpH,EAAO,UAAU,EAAE,KACtFA,EAAO,UAAUoH,CAAW,CAEpC,CAMA,sBAAsBpH,EAAgB,CAClC,IAAMM,EAAW,KAAK,SAAS,SACzBC,EAAcD,EAAS,QAAQ,UAAU,EAC3CU,EAASV,EACTW,EAAQ,GACRV,IAAgB,KAChBS,EAASV,EAAS,MAAM,EAAGC,CAAW,EACtCU,EAAQX,EAAS,MAAMC,EAAc,CAAiB,GAE1D,IAAMC,EAAcQ,EAAO,KAAK,EAC1BP,EAAYQ,EAAM,KAAK,EAEvBf,EAASF,EAAO,UAAU,EAC5Ba,EAAOb,EAAO,QAAQE,EAAO,IAAI,EACjC6D,EAAWlD,EAAK,QAAQL,CAAW,EACnCwD,EAASvD,EAAYI,EAAK,YAAYJ,CAAS,EAAI,GACnD4G,EAAW,GAMf,GALI7G,GAAeC,EACf4G,EAAWtD,IAAa,IAAMC,IAAW,IAAM9D,EAAO,IAAM6D,EAAWvD,EAAY,QAAUN,EAAO,IAAM8D,EACnGxD,IACP6G,EAAWtD,IAAa,IAAM7D,EAAO,IAAM6D,EAAWvD,EAAY,QAElE6G,EAAU,CAEV,IAAIX,EAAc7F,EACdL,IACAkG,EAAcA,EAAY,QAAQlG,EAAa,EAAE,GAEjDC,IACAiG,EAAcA,EAAY,QAAQjG,EAAW,EAAE,GAEnDiG,EAAcA,EAAY,KAAK,EAC/B1G,EAAO,QAAQE,EAAO,KAAMwG,CAAW,CAC3C,CACJ,CACJ",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "logDev", "args", "defaultStyles", "CommentFormatPlugin", "CommentFormatSettingTab", "editor", "selection", "cursor", "from", "to", "lineText", "template", "cursorIndex", "markerStart", "markerEnd", "isAtMarkerBoundary", "sel", "marker", "line", "i", "shouldCleanup", "before", "after", "force", "mainTemplate", "mainId", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "commentText", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "clampCursorPos", "pos", "allLines", "ch", "markerStartNormalized", "markerEndNormalized", "text", "wordBounds", "getWordBounds", "regex", "match", "isTextCommentedExact", "str", "scanForFirst", "fromLine", "fromCh", "opposite", "direction", "markerTrim", "oppositeTrim", "l", "searchStart", "idx", "isComment", "commentStartPos", "commentEndPos", "beforeType", "afterType", "containsPartOfMarker", "selectionText", "foundStart", "foundEnd", "startIdx", "endIdx", "left", "right", "searchLine", "searchCh", "found", "atStartBoundary", "atEndBoundary", "startLineIdx", "startChIdx", "endLineIdx", "endChIdx", "startLine", "startMarkerWithSpace", "updatedLine", "endMarkerWithSpace", "endLine", "toLine", "newText", "newCursorLine", "newCursorCh", "lastLine", "lineLen", "clamped", "useWord", "removalUsedStart", "removalUsedEnd", "removalInside", "removalCheckText", "style", "lineStart", "lineEnd", "removeNearestMarkersFromWordOrSelection", "selectionStart", "selectionEnd", "between", "usedStart", "usedEnd", "inside", "checkText", "buildCommented", "stripCommented", "uncommented", "wordText", "safeUncommented", "selFrom", "selTo", "newCh", "trimmedText", "commented", "cursorPos", "startOffset", "finalCursor", "isInside"]
}
