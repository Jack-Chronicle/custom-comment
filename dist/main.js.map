{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect, RangeSetBuilder } from '@codemirror/state';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default fallback comment styles for removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\n/**\r\n * Main plugin class for Custom Comments.\r\n * Handles command registration, settings, and comment toggling logic.\r\n */\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n    private _cleanupGuard: boolean = false;\r\n\r\n    /**\r\n     * Called when the plugin is loaded. Registers commands and settings tab.\r\n     */\r\n    async onload() {\r\n        logDev('Plugin loading...');\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        this.registerMarkerCommands();\r\n        // Removed: auto-cleanup event registration\r\n    }\r\n\r\n    /**\r\n     * Registers all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        if (force && this._markerCommandIds) {\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Register main toggle command\r\n        let mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Register additional marker commands if enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n        logDev('Marker commands registered:', this._markerCommandIds);\r\n    }\r\n\r\n    /**\r\n     * Loads plugin settings from disk.\r\n     */\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n        logDev('Settings loaded:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Saves plugin settings to disk.\r\n     */\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n        logDev('Settings saved:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n        logDev('Plugin reloaded');\r\n    }\r\n\r\n    /**\r\n     * Inserts a comment at the current cursor position using the template.\r\n     */\r\n    insertComment(editor: Editor) {\r\n        let template = this.settings.template;\r\n        let cursorIndex = template.indexOf(\"{cursor}\");\r\n        if (cursorIndex === -1) {\r\n            editor.replaceSelection(template);\r\n            logDev('Inserted template (no cursor placeholder)');\r\n            return;\r\n        }\r\n        let before = template.slice(0, cursorIndex).trim();\r\n        let after = template.slice(cursorIndex + \"{cursor}\".length).trim();\r\n        const commentText = `${before} ${after}`.replace(/\\s+/g, ' ').trim();\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(`${before}  ${after}`.replace(/\\s+/g, ' ').replace(' ', ' {cursor} '));\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length + 1;\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n        logDev('Inserted comment at cursor');\r\n    }\r\n\r\n    /**\r\n     * Toggles comment using a specific marker set, or the default template if none provided.\r\n     * Handles selection, word, and cursor modes robustly.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n\r\n        // 1. Marker Extraction and Normalization\r\n        let markerStart: string, markerEnd: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start.trim();\r\n            markerEnd = markerSet.end.trim();\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before.trim();\r\n            markerEnd = after.trim();\r\n        }\r\n        function normalize(str: string) {\r\n            return str.replace(/\\s+/g, ' ').trim();\r\n        }\r\n        const normStart = normalize(markerStart);\r\n        const normEnd = normalize(markerEnd);\r\n\r\n        // 3.1 Marker Search in Selection\r\n        function findMarkerInText(marker: string, text: string) {\r\n            let idx = text.indexOf(marker);\r\n            if (idx !== -1) return { idx, full: true };\r\n            // Try partials (from length-1 down to 1)\r\n            for (let len = marker.length - 1; len > 0; len--) {\r\n                if (text.includes(marker.slice(0, len))) return { idx: text.indexOf(marker.slice(0, len)), full: false, partial: marker.slice(0, len) };\r\n                if (text.includes(marker.slice(-len))) return { idx: text.indexOf(marker.slice(-len)), full: false, partial: marker.slice(-len) };\r\n            }\r\n            return { idx: -1, full: false };\r\n        }\r\n        // --- Advanced Partial Marker Detection ---\r\n        function confirmPartialMarker({\r\n            line,\r\n            marker,\r\n            partialIdx,\r\n            isStart,\r\n            otherMarker,\r\n            uniqueMarkers = true\r\n        }: {\r\n            line: string,\r\n            marker: string,\r\n            partialIdx: number,\r\n            isStart: boolean,\r\n            otherMarker: string,\r\n            uniqueMarkers?: boolean\r\n        }) {\r\n            const len = marker.length;\r\n            let fullIdx = -1;\r\n            for (let i = Math.max(0, partialIdx - len + 1); i <= partialIdx; i++) {\r\n                if (line.slice(i, i + len) === marker) {\r\n                    fullIdx = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (fullIdx === -1) {\r\n                for (let i = partialIdx; i <= Math.min(line.length - len, partialIdx + len - 1); i++) {\r\n                    if (line.slice(i, i + len) === marker) {\r\n                        fullIdx = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (fullIdx === -1) return { confirmed: false };\r\n            if (isStart) {\r\n                let nextEnd = line.indexOf(otherMarker, fullIdx + len);\r\n                if (nextEnd === -1) return { confirmed: false };\r\n                if (uniqueMarkers) {\r\n                    let nextStart = line.indexOf(marker, fullIdx + len);\r\n                    if (nextStart !== -1 && nextStart < nextEnd) return { confirmed: false };\r\n                }\r\n                return { confirmed: true, startIdx: fullIdx, endIdx: nextEnd };\r\n            } else {\r\n                let prevStart = line.lastIndexOf(otherMarker, fullIdx - 1);\r\n                if (prevStart === -1) return { confirmed: false };\r\n                if (uniqueMarkers) {\r\n                    let prevEnd = line.lastIndexOf(marker, fullIdx - 1);\r\n                    if (prevEnd !== -1 && prevEnd > prevStart) return { confirmed: false };\r\n                }\r\n                return { confirmed: true, startIdx: prevStart, endIdx: fullIdx };\r\n            }\r\n        }\r\n        // --- Helper: Search for marker in line in a direction ---\r\n        function searchMarkerInLine(marker: string, fromIdx: number, direction: 'back' | 'forward'): number {\r\n            if (direction === 'back') {\r\n                return line.lastIndexOf(marker, fromIdx);\r\n            } else {\r\n                return line.indexOf(marker, fromIdx);\r\n            }\r\n        }\r\n\r\n        // 2. Efficient Comment Detection\r\n        function isRegionCommented(text: string, start: string, end: string) {\r\n            const trimmed = text.trim();\r\n            if (start && end) {\r\n                return trimmed.startsWith(start) && trimmed.endsWith(end);\r\n            } else if (start) {\r\n                return trimmed.startsWith(start);\r\n            }\r\n            return false;\r\n        }\r\n        // fallback style detection\r\n        function detectFallback(text: string) {\r\n            for (const style of defaultStyles) {\r\n                const s = normalize(style.start);\r\n                const e = normalize(style.end);\r\n                if (isRegionCommented(text, s, e)) {\r\n                    return { found: true, markerStart: style.start, markerEnd: style.end };\r\n                }\r\n            }\r\n            return { found: false };\r\n        }\r\n\r\n        // 3. Mode Decision\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let line = editor.getLine(cursor.line);\r\n        let text: string;\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        if (selection) {\r\n            text = selection;\r\n        } else {\r\n            wordBounds = getWordBounds(line, cursor.ch);\r\n            if (wordBounds && cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                text = line.slice(wordBounds.start, wordBounds.end);\r\n                from = { line: cursor.line, ch: wordBounds.start };\r\n                to = { line: cursor.line, ch: wordBounds.end };\r\n            } else {\r\n                text = '';\r\n                from = { line: cursor.line, ch: cursor.ch };\r\n                to = { line: cursor.line, ch: cursor.ch };\r\n            }\r\n        }\r\n\r\n        // 4. Comment Region Detection\r\n        let startIdx = -1, endIdx = -1;\r\n        let region = '', regionIsComment = false;\r\n        let usedStart = normStart, usedEnd = normEnd;\r\n        let uniqueMarkers = Boolean(usedStart && usedEnd && usedStart !== usedEnd);\r\n        // --- Detection Logging ---\r\n        logDev('[Detection] selection:', selection);\r\n        logDev('[Detection] text:', text);\r\n        const foundStart = findMarkerInText(normStart, text);\r\n        const foundEnd = findMarkerInText(normEnd, text);\r\n        logDev('[Detection] foundStart:', foundStart);\r\n        logDev('[Detection] foundEnd:', foundEnd);\r\n        if (selection) {\r\n            // Find all start and end marker positions in the entire document\r\n            const markerStarts = [];\r\n            const markerEnds = [];\r\n            const lineCount = editor.lineCount();\r\n            for (let i = 0; i < lineCount; i++) {\r\n                const lineText = editor.getLine(i);\r\n                let idx = 0;\r\n                while ((idx = lineText.indexOf(normStart, idx)) !== -1) {\r\n                    markerStarts.push({ line: i, ch: idx });\r\n                    idx += normStart.length;\r\n                }\r\n                idx = 0;\r\n                while ((idx = lineText.indexOf(normEnd, idx)) !== -1) {\r\n                    markerEnds.push({ line: i, ch: idx });\r\n                    idx += normEnd.length;\r\n                }\r\n            }\r\n            // Find the marker pair that encompasses the selection (fully or partially overlaps)\r\n            let pairToRemove = null;\r\n            // Use stack to ensure correct matching of start/end pairs\r\n            const stack: { line: number, ch: number }[] = [];\r\n            for (let i = 0, s = 0, e = 0; i < markerStarts.length + markerEnds.length;) {\r\n                let nextStart = s < markerStarts.length ? markerStarts[s] : null;\r\n                let nextEnd = e < markerEnds.length ? markerEnds[e] : null;\r\n                let isStart = false;\r\n                if (nextStart && (!nextEnd || nextStart.line < nextEnd.line || (nextStart.line === nextEnd.line && nextStart.ch < nextEnd.ch))) {\r\n                    stack.push(nextStart);\r\n                    s++;\r\n                    isStart = true;\r\n                } else if (nextEnd) {\r\n                    if (stack.length > 0) {\r\n                        const start = stack.pop();\r\n                        if (start) { // Type guard for start\r\n                            const end = nextEnd;\r\n                            // Marker region\r\n                            const markerRegionStart = { line: start.line, ch: start.ch };\r\n                            const markerRegionEnd = { line: end.line, ch: end.ch + normEnd.length };\r\n                            // Selection must be fully or partially within the marker region (overlap)\r\n                            const selStart = from;\r\n                            const selEnd = to;\r\n                            const selectionWithinMarker =\r\n                                (selStart.line < markerRegionEnd.line || (selStart.line === markerRegionEnd.line && selStart.ch < markerRegionEnd.ch)) &&\r\n                                (selEnd.line > markerRegionStart.line || (selEnd.line === markerRegionStart.line && selEnd.ch > markerRegionStart.ch));\r\n                            const selectionCompletelyBefore =\r\n                                (selEnd.line < markerRegionStart.line) ||\r\n                                (selEnd.line === markerRegionStart.line && selEnd.ch <= markerRegionStart.ch);\r\n                            const selectionCompletelyAfter =\r\n                                (selStart.line > markerRegionEnd.line) ||\r\n                                (selStart.line === markerRegionEnd.line && selStart.ch >= markerRegionEnd.ch);\r\n                            if (selectionWithinMarker && !selectionCompletelyBefore && !selectionCompletelyAfter) {\r\n                                pairToRemove = { start, end };\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    e++;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if (pairToRemove) {\r\n                // Remove the marker pair in a single transaction so undo restores both\r\n                const { start, end } = pairToRemove;\r\n                let startSpace = 0;\r\n                const startLineText = editor.getLine(start.line);\r\n                if (startLineText[start.ch + normStart.length] === ' ') {\r\n                    startSpace = 1;\r\n                }\r\n                let endSpace = 0;\r\n                const endLineText = editor.getLine(end.line);\r\n                if (end.ch > 0 && endLineText[end.ch - 1] === ' ') {\r\n                    endSpace = 1;\r\n                }\r\n                // Calculate how many characters to shift selection start/end\r\n                let removedBeforeStartLine = 0;\r\n                let removedBeforeEndLine = 0;\r\n                let removedWithinEndLine = 0;\r\n                // If marker is on the same line as selection start\r\n                if (start.line === from.line) {\r\n                    if (start.ch < from.ch) {\r\n                        removedBeforeStartLine += normStart.length + startSpace;\r\n                    } else if (start.ch >= from.ch && start.ch < to.ch && from.line === to.line) {\r\n                        removedWithinEndLine += normStart.length + startSpace;\r\n                    }\r\n                }\r\n                // If marker is on the same line as selection end\r\n                if (end.line === to.line) {\r\n                    if (end.ch < to.ch) {\r\n                        removedBeforeEndLine += normEnd.length + endSpace;\r\n                    } else if (end.ch >= from.ch && end.ch < to.ch && from.line === to.line) {\r\n                        removedWithinEndLine += normEnd.length + endSpace;\r\n                    }\r\n                }\r\n                // Track removed characters per line (before and within selection)\r\n                const removedBefore: Record<number, number> = {};\r\n                const removedWithin: Record<number, number> = {};\r\n                // Start marker\r\n                if (start.line === from.line && start.ch < from.ch) {\r\n                    removedBefore[start.line] = (removedBefore[start.line] || 0) + normStart.length + startSpace;\r\n                } else if (start.line === to.line && start.ch < to.ch) {\r\n                    // If start marker is on the end line and before end\r\n                    removedBefore[start.line] = (removedBefore[start.line] || 0) + normStart.length + startSpace;\r\n                } else if (start.line > from.line && start.line < to.line) {\r\n                    // Marker is within selection, on a line between start and end\r\n                    removedWithin[start.line] = (removedWithin[start.line] || 0) + normStart.length + startSpace;\r\n                } else if (start.line === from.line && start.ch >= from.ch && (from.line === to.line ? start.ch < to.ch : true)) {\r\n                    // Marker is within selection on start line\r\n                    removedWithin[start.line] = (removedWithin[start.line] || 0) + normStart.length + startSpace;\r\n                }\r\n                // End marker\r\n                if (end.line === to.line && end.ch < to.ch) {\r\n                    removedBefore[end.line] = (removedBefore[end.line] || 0) + normEnd.length + endSpace;\r\n                } else if (end.line === from.line && end.ch < from.ch) {\r\n                    removedBefore[end.line] = (removedBefore[end.line] || 0) + normEnd.length + endSpace;\r\n                } else if (end.line > from.line && end.line < to.line) {\r\n                    removedWithin[end.line] = (removedWithin[end.line] || 0) + normEnd.length + endSpace;\r\n                } else if (end.line === to.line && end.ch >= from.ch && (from.line === to.line ? end.ch < to.ch : true)) {\r\n                    // Marker is within selection on end line\r\n                    removedWithin[end.line] = (removedWithin[end.line] || 0) + normEnd.length + endSpace;\r\n                }\r\n                editor.transaction({\r\n                    changes: [\r\n                        { from: { line: end.line, ch: end.ch - endSpace }, to: { line: end.line, ch: end.ch + normEnd.length }, text: '' },\r\n                        { from: { line: start.line, ch: start.ch }, to: { line: start.line, ch: start.ch + normStart.length + startSpace }, text: '' }\r\n                    ]\r\n                });\r\n                // Adjust selection\r\n                let selFrom = { ...from };\r\n                let selTo = { ...to };\r\n                if (removedBefore[selFrom.line]) {\r\n                    selFrom.ch = Math.max(0, selFrom.ch - removedBefore[selFrom.line]);\r\n                }\r\n                if (removedBefore[selTo.line] || removedWithin[selTo.line]) {\r\n                    selTo.ch = Math.max(selFrom.ch, selTo.ch - (removedBefore[selTo.line] || 0) - (removedWithin[selTo.line] || 0));\r\n                }\r\n                // For debugging: collect removed character details\r\n                const removedCharsLog: Array<{ line: number, type: 'before' | 'within', count: number }> = [];\r\n                for (const lineStr in removedBefore) {\r\n                    const line = Number(lineStr);\r\n                    removedCharsLog.push({ line, type: 'before', count: removedBefore[line] });\r\n                }\r\n                for (const lineStr in removedWithin) {\r\n                    const line = Number(lineStr);\r\n                    removedCharsLog.push({ line, type: 'within', count: removedWithin[line] });\r\n                }\r\n                logDev('Uncommented marker pair encompassing selection', { from, to, pairToRemove, removedBefore, removedWithin, selFrom, selTo, removedCharsLog });\r\n                editor.setSelection(selFrom, selTo);\r\n                return;\r\n            }\r\n            // If no marker pair was found, wrap the selection in a comment and return\r\n            if (selection) {\r\n                const selText = editor.getRange(from, to);\r\n                const commented = normStart + (selText ? ' ' : '') + selText + (selText ? ' ' : '') + normEnd;\r\n                editor.replaceRange(commented, from, to);\r\n                const startMarkerLen = normStart.length + (selText ? 1 : 0);\r\n                const selFrom = { line: from.line, ch: from.ch + startMarkerLen };\r\n                let selTo;\r\n                if (from.line === to.line) {\r\n                    selTo = { line: to.line, ch: to.ch + startMarkerLen };\r\n                } else {\r\n                    selTo = { line: to.line, ch: to.ch };\r\n                }\r\n                editor.setSelection(selFrom, selTo);\r\n                logDev('Commented region (no marker pair found)', { from, to, commented });\r\n                return;\r\n            }\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        // 5. Toggle Logic\r\n        if (regionIsComment) {\r\n            let beforeRegion = line.slice(0, startIdx);\r\n            let afterRegion = line.slice((usedEnd && endIdx !== -1 ? endIdx + usedEnd.length : line.length));\r\n            let startMarkerExtra = 0;\r\n            if (region.startsWith(' ')) {\r\n                region = region.slice(1);\r\n                startMarkerExtra = 1;\r\n            }\r\n            let endMarkerExtra = 0;\r\n            if (region.endsWith(' ')) {\r\n                region = region.slice(0, -1);\r\n                endMarkerExtra = 1;\r\n            }\r\n            let newLine = beforeRegion + region + afterRegion;\r\n            editor.setLine(cursor.line, newLine);\r\n            if (selection) {\r\n                let selFromCh = from.ch;\r\n                let selToCh = to.ch;\r\n                if (from.ch <= startIdx + usedStart.length + startMarkerExtra) {\r\n                    selFromCh = startIdx;\r\n                } else {\r\n                    selFromCh = from.ch - usedStart.length + startMarkerExtra;\r\n                }\r\n                if (usedEnd && endIdx !== -1 && to.ch >= endIdx) {\r\n                    selToCh = startIdx + region.length;\r\n                } else {\r\n                    selToCh = to.ch - usedStart.length + startMarkerExtra;\r\n                }\r\n                selFromCh = Math.max(0, selFromCh);\r\n                selToCh = Math.max(selFromCh, selToCh);\r\n                const selFrom = { line: cursor.line, ch: selFromCh };\r\n                const selTo = { line: cursor.line, ch: selToCh };\r\n                editor.setSelection(selFrom, selTo);\r\n                logDev('Uncommented region', { from, to, region });\r\n            } else {\r\n                return;\r\n            }\r\n        } else {\r\n            if (selection) {\r\n                const selText = editor.getRange(from, to);\r\n                const commented = usedStart + (selText ? ' ' : '') + selText + (selText ? ' ' : '') + usedEnd;\r\n                editor.replaceRange(commented, from, to);\r\n                const startMarkerLen = usedStart.length + (selText ? 1 : 0);\r\n                const endMarkerLen = usedEnd.length + (selText ? 1 : 0);\r\n                const selFrom = { line: from.line, ch: from.ch + startMarkerLen };\r\n                let selTo;\r\n                if (from.line === to.line) {\r\n                    selTo = { line: to.line, ch: to.ch + startMarkerLen };\r\n                } else {\r\n                    selTo = { line: to.line, ch: to.ch };\r\n                }\r\n                editor.setSelection(selFrom, selTo);\r\n                logDev('Commented region', { from, to, commented });\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx + markerEnd.length;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "logDev", "args", "defaultStyles", "CommentFormatPlugin", "CommentFormatSettingTab", "force", "mainTemplate", "cursorIndex", "before", "after", "mainId", "editor", "marker", "i", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "template", "commentText", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "markerStart", "markerEnd", "normalize", "str", "normStart", "normEnd", "findMarkerInText", "text", "idx", "len", "confirmPartialMarker", "line", "partialIdx", "isStart", "otherMarker", "uniqueMarkers", "fullIdx", "nextEnd", "nextStart", "prevStart", "prevEnd", "searchMarkerInLine", "fromIdx", "direction", "isRegionCommented", "trimmed", "detectFallback", "style", "s", "e", "selection", "cursor", "to", "wordBounds", "getWordBounds", "ch", "regex", "match", "startIdx", "endIdx", "region", "regionIsComment", "usedStart", "usedEnd", "foundStart", "foundEnd", "markerStarts", "markerEnds", "lineCount", "lineText", "pairToRemove", "stack", "markerRegionStart", "markerRegionEnd", "selStart", "selEnd", "selectionWithinMarker", "selectionCompletelyBefore", "selectionCompletelyAfter", "startSpace", "endSpace", "endLineText", "removedBeforeStartLine", "removedBeforeEndLine", "removedWithinEndLine", "removedBefore", "removedWithin", "selFrom", "selTo", "removedCharsLog", "lineStr", "selText", "commented", "startMarkerLen", "beforeRegion", "afterRegion", "startMarkerExtra", "endMarkerExtra", "newLine", "selFromCh", "selToCh", "endMarkerLen", "clampCursorPos", "pos", "allLines", "finalCursor", "isInside", "uncommented"]
}
