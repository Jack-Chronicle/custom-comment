{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect } from '@codemirror/state';\r\n// @ts-ignore\r\nimport { RangeSetBuilder } from '@codemirror/state';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default styles for fallback removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n\r\n    async onload() {\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register the reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        // Register all marker commands (main + enabled additional marker sets)\r\n        this.registerMarkerCommands();\r\n        // Post processor removed as requested.\r\n    }\r\n\r\n    /**\r\n     * Register all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        // Remove previously registered marker commands if force is true\r\n        if (force && this._markerCommandIds) {\r\n            // Do NOT remove commands dynamically; just clear our tracking array\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Main command: always present, always visible, always named 'Toggle Comment: (%%|%%)'\r\n        const mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Only register marker commands for marker sets that exist and are enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n    }\r\n\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n    }\r\n\r\n    insertComment(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n\r\n        if (cursorIndex === -1) {\r\n            // Fallback: insert template and move cursor to start\r\n            editor.replaceSelection(template);\r\n            return;\r\n        }\r\n\r\n        // Remove {cursor} and track where it was\r\n        const before = template.slice(0, cursorIndex);\r\n        const after = template.slice(cursorIndex + \"{cursor}\".length);\r\n\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(before + after);\r\n\r\n        // Calculate the new cursor position\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length;\r\n\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Toggle comment using a specific marker set, or the default template if none provided.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n        // --- Clamp helper ---\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        let markerStart: string, markerEnd: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start;\r\n            markerEnd = markerSet.end;\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before;\r\n            markerEnd = after;\r\n        }\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let text: string;\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        let line = editor.getLine(cursor.line);\r\n        // Helper to find word bounds at a given ch, ignoring punctuation\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            // Only match sequences of letters, numbers, or underscores (ignore punctuation)\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        function isTextCommentedExact(str: string, start: string, end: string) {\r\n            if (!start) return false;\r\n            if (end) {\r\n                return str.startsWith(start) && str.endsWith(end);\r\n            } else {\r\n                return str.startsWith(start);\r\n            }\r\n        }\r\n        // Utility: Scan lines in a direction for a marker, stopping if the opposite marker is found first\r\n        function scanForFirst(lines: string[], fromLine: number, fromCh: number, marker: string, opposite: string, direction: 'back' | 'forward'): { type: 'marker' | 'opposite' | null, pos: { line: number, ch: number } | null } {\r\n            // Remove leading/trailing whitespace for marker matching\r\n            const markerTrim = marker.trim();\r\n            const oppositeTrim = opposite.trim();\r\n            if (direction === 'back') {\r\n                for (let l = fromLine; l >= 0; l--) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : line.length;\r\n                    for (let idx = searchStart - 1; idx >= 0; idx--) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            } else {\r\n                for (let l = fromLine; l < lines.length; l++) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : 0;\r\n                    for (let idx = searchStart; idx <= line.length - Math.min(markerTrim.length, oppositeTrim.length); idx++) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            }\r\n            return { type: null, pos: null };\r\n        }\r\n        // Main logic for comment detection\r\n        let isComment = false;\r\n        let commentStartPos: { line: number, ch: number } | null = null;\r\n        let commentEndPos: { line: number, ch: number } | null = null;\r\n        const allLines = editor.getValue().split('\\n');\r\n        if (markerStart && markerEnd) {\r\n            let beforeType, afterType;\r\n            if (selection) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            } else {\r\n                const before = scanForFirst(allLines, cursor.line, cursor.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, cursor.line, cursor.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            }\r\n            if (beforeType === 'marker' && afterType === 'marker') {\r\n                isComment = true;\r\n            } else if (beforeType === 'opposite' && afterType === 'opposite') {\r\n                isComment = false;\r\n            } else {\r\n                isComment = false;\r\n            }\r\n        }\r\n        // Log with 1-based line/ch for user clarity\r\n        logDev('comment:', isComment, {\r\n            start: commentStartPos ? { line: commentStartPos.line + 1, ch: commentStartPos.ch + 1 } : null,\r\n            end: commentEndPos ? { line: commentEndPos.line + 1, ch: commentEndPos.ch + 1 } : null\r\n        });\r\n        // If isComment is true, remove the detected markers\r\n        if (isComment && commentStartPos && commentEndPos) {\r\n            // Remove start marker (match full marker, not trimmed)\r\n            let startLine = allLines[commentStartPos.line];\r\n            allLines[commentStartPos.line] = startLine.slice(0, commentStartPos.ch) + startLine.slice(commentStartPos.ch + markerStart.length);\r\n            // Adjust end marker position if on same line as start\r\n            let endLineIdx = commentEndPos.line;\r\n            let endChIdx = commentEndPos.ch;\r\n            if (commentStartPos.line === commentEndPos.line) {\r\n                endChIdx -= markerStart.length;\r\n            }\r\n            // Remove end marker (match full marker, not trimmed)\r\n            let endLine = allLines[endLineIdx];\r\n            // Remove any single space immediately before the end marker (to avoid trailing space)\r\n            let spaceAdjust = 0;\r\n            if (endChIdx > 0 && endLine[endChIdx - 1] === ' ') {\r\n                endChIdx--;\r\n                spaceAdjust = 1;\r\n            }\r\n            allLines[endLineIdx] = endLine.slice(0, endChIdx) + endLine.slice(endChIdx + markerEnd.length);\r\n            // Replace the affected lines in the editor\r\n            const fromLine = Math.min(commentStartPos.line, commentEndPos.line);\r\n            const toLine = Math.max(commentStartPos.line, commentEndPos.line);\r\n            const newText = allLines.slice(fromLine, toLine + 1).join('\\n');\r\n            editor.replaceRange(newText, { line: fromLine, ch: 0 }, { line: toLine, ch: editor.getLine(toLine).length });\r\n            // Adjust cursor position: keep it at the same logical place after removing start marker\r\n            let newCursorLine = from.line;\r\n            let newCursorCh = from.ch - markerStart.length;\r\n            if (newCursorCh < 0) newCursorCh = 0;\r\n            // If cursor would be outside the document, clamp to end\r\n            const lastLine = allLines.length - 1;\r\n            if (newCursorLine > lastLine) newCursorLine = lastLine;\r\n            let lineLen = allLines[newCursorLine]?.length ?? 0;\r\n            if (newCursorCh > lineLen) newCursorCh = lineLen;\r\n            // If the calculated line/ch is outside the document, set to very end\r\n            let clamped = clampCursorPos({ line: newCursorLine, ch: newCursorCh });\r\n            editor.setCursor(clamped);\r\n            return;\r\n        }\r\n        // Decide word or insert-at-cursor mode\r\n        let useWord = false;\r\n        wordBounds = getWordBounds(line, cursor.ch);\r\n        if (selection) {\r\n            useWord = false;\r\n        } else if (wordBounds) {\r\n            // Cursor is inside a word\r\n            if (cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                // Always operate on the word if cursor is inside the word (not at boundary)\r\n                useWord = true;\r\n            } else if (this.settings.wordOnlyMode && (cursor.ch === wordBounds.start || cursor.ch === wordBounds.end)) {\r\n                // Only operate on the word at boundary if wordOnlyMode is enabled\r\n                useWord = true;\r\n            } else {\r\n                // At word boundary and wordOnlyMode is off: insert at cursor\r\n                useWord = false;\r\n            }\r\n        }\r\n        logDev('Mode:', selection ? 'selection' : useWord ? 'word' : 'insert', { selection, wordBounds, useWord });\r\n        // Determine text and range\r\n        if (selection) {\r\n            text = selection;\r\n        } else if (useWord && wordBounds) {\r\n            text = line.slice(wordBounds.start, wordBounds.end);\r\n            from = { line: cursor.line, ch: wordBounds.start };\r\n            to = { line: cursor.line, ch: wordBounds.end };\r\n        } else {\r\n            text = '';\r\n            from = { line: cursor.line, ch: cursor.ch };\r\n            to = { line: cursor.line, ch: cursor.ch };\r\n        }\r\n        // Remove block comment logic (findBlockCommentBounds) as it is not needed for the new comment detection\r\n        // Check if selection or word/line is inside a comment (custom or default)\r\n        // --- Removal takes priority ---\r\n        let removalUsedStart = markerStart;\r\n        let removalUsedEnd = markerEnd;\r\n        let removalInside = false;\r\n        let removalCheckText = text;\r\n        if (selection) {\r\n            if (removalUsedStart && removalUsedEnd && selection.startsWith(removalUsedStart) && selection.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = selection;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && selection.startsWith(style.start) && selection.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = selection;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside) {\r\n                const lineStart = editor.getLine(from.line);\r\n                const lineEnd = editor.getLine(to.line);\r\n                if (removalUsedStart && removalUsedEnd && lineStart.startsWith(removalUsedStart) && lineEnd.endsWith(removalUsedEnd)) {\r\n                    removalInside = true;\r\n                    removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                } else {\r\n                    for (const style of defaultStyles) {\r\n                        if (style.start && style.end && lineStart.startsWith(style.start) && lineEnd.endsWith(style.end)) {\r\n                            removalUsedStart = style.start;\r\n                            removalUsedEnd = style.end;\r\n                            removalInside = true;\r\n                            removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (useWord && wordBounds) {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside && removalUsedStart && removalUsedEnd && text.startsWith(removalUsedStart) && text.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = text;\r\n            } else if (!removalInside) {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && text.startsWith(style.start) && text.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = text;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Remove the nearest comment markers before/after the word or selection\r\n        function removeNearestMarkersFromWordOrSelection(text: string, start: string, end: string, selectionStart: number, selectionEnd: number): { result: string, newStart: number, newEnd: number } {\r\n            // No-op: marker removal logic removed as requested\r\n            return { result: text, newStart: selectionStart, newEnd: selectionEnd };\r\n        }\r\n        if (removalInside) {\r\n            // No-op: skip marker removal entirely\r\n            return;\r\n        }\r\n        // Check if text/word/selection is commented\r\n        let usedStart = markerStart;\r\n        let usedEnd = markerEnd;\r\n        let inside = false;\r\n        let checkText = text;\r\n        if (selection) {\r\n            checkText = text;\r\n        } else if (useWord && wordBounds) {\r\n            checkText = line.slice(wordBounds.start, wordBounds.end);\r\n        } else {\r\n            checkText = text;\r\n        }\r\n        if (usedStart && isTextCommentedExact(checkText, usedStart, usedEnd)) {\r\n            inside = true;\r\n        } else {\r\n            for (const style of defaultStyles) {\r\n                if (style.start && isTextCommentedExact(checkText, style.start, style.end)) {\r\n                    usedStart = style.start;\r\n                    usedEnd = style.end;\r\n                    inside = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (inside) {\r\n            logDev('Removing exact comment markers', { usedStart, usedEnd, checkText });\r\n            // Remove comment markers (exact, not trimmed)\r\n            let uncommented = checkText;\r\n            let removedStartLen = 0;\r\n            if (usedStart && uncommented.startsWith(usedStart)) {\r\n                removedStartLen = usedStart.length;\r\n                uncommented = uncommented.slice(usedStart.length);\r\n            }\r\n            if (usedEnd && uncommented.endsWith(usedEnd)) {\r\n                uncommented = uncommented.slice(0, -usedEnd.length);\r\n            }\r\n            if (selection) {\r\n                editor.replaceSelection(uncommented);\r\n                const selFrom = clampCursorPos(from);\r\n                const selTo = clampCursorPos({ line: to.line, ch: to.ch - removedStartLen });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(uncommented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = Math.max(wordBounds.start, cursor.ch - removedStartLen);\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                editor.replaceRange(uncommented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch });\r\n                editor.setCursor(clamped);\r\n            }\r\n        } else {\r\n            logDev('Adding comment markers', { markerStart, markerEnd, text });\r\n            // Add comment markers, preserving template spaces\r\n            let commented = markerStart + text + markerEnd;\r\n            if (selection) {\r\n                editor.replaceSelection(commented);\r\n                const startOffset = markerStart.length;\r\n                const selFrom = clampCursorPos({ line: from.line, ch: from.ch + startOffset });\r\n                const selTo = clampCursorPos({ line: to.line, ch: to.ch + startOffset });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = cursor.ch + markerStart.length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                // Insert at cursor\r\n                editor.replaceRange(commented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch + markerStart.length });\r\n                editor.setCursor(clamped);\r\n            }\r\n        }\r\n        // After inserting, clamp cursor to end of document if needed\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            // Remove markers from the line\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "logDev", "args", "defaultStyles", "CommentFormatPlugin", "CommentFormatSettingTab", "force", "mainTemplate", "cursorIndex", "before", "after", "mainId", "editor", "marker", "i", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "template", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "clampCursorPos", "pos", "allLines", "line", "ch", "markerStart", "markerEnd", "selection", "cursor", "text", "to", "wordBounds", "getWordBounds", "regex", "match", "isTextCommentedExact", "str", "scanForFirst", "fromLine", "fromCh", "opposite", "direction", "markerTrim", "oppositeTrim", "l", "searchStart", "idx", "isComment", "commentStartPos", "commentEndPos", "beforeType", "afterType", "startLine", "endLineIdx", "endChIdx", "endLine", "spaceAdjust", "toLine", "newText", "newCursorLine", "newCursorCh", "lastLine", "lineLen", "clamped", "useWord", "removalUsedStart", "removalUsedEnd", "removalInside", "removalCheckText", "style", "lineStart", "lineEnd", "removeNearestMarkersFromWordOrSelection", "selectionStart", "selectionEnd", "usedStart", "usedEnd", "inside", "checkText", "uncommented", "removedStartLen", "selFrom", "selTo", "newCh", "commented", "startOffset", "finalCursor", "startIdx", "endIdx", "isInside"]
}
