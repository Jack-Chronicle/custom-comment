{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts", "../src/utils/normalize.ts", "../src/utils/findMarkerInText.ts", "../src/utils/getWordBounds.ts", "../src/utils/getSelectionRange.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// @ts-ignore\r\nimport { EditorView, Decoration, WidgetType } from '@codemirror/view';\r\n// @ts-ignore\r\nimport { StateField, StateEffect, RangeSetBuilder } from '@codemirror/state';\r\n\r\nimport { normalize } from './utils/normalize';\r\nimport { findMarkerInText } from './utils/findMarkerInText';\r\nimport { confirmPartialMarker } from './utils/confirmPartialMarker';\r\nimport { searchMarkerInLine } from './utils/searchMarkerInLine';\r\nimport { isRegionCommented } from './utils/isRegionCommented';\r\nimport { detectFallback } from './utils/detectFallback';\r\nimport { getWordBounds } from './utils/getWordBounds';\r\nimport { getSelectionRange } from './utils/getSelectionRange';\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\n// Default fallback comment styles for removal\r\nconst defaultStyles = [\r\n    { start: \"%%\", end: \"%%\" },\r\n    { start: \"<!--\", end: \"-->\" },\r\n    { start: \"//\", end: \"\" },\r\n];\r\n\r\n/**\r\n * Main plugin class for Custom Comments.\r\n * Handles command registration, settings, and comment toggling logic.\r\n */\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n    private _markerCommandIds: string[] = [];\r\n    private _cleanupGuard: boolean = false;\r\n\r\n    /**\r\n     * Called when the plugin is loaded. Registers commands and settings tab.\r\n     */\r\n    async onload() {\r\n        logDev('Plugin loading...');\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        // Register reload marker commands command\r\n        this.addCommand({\r\n            id: \"reload-marker-commands\",\r\n            name: \"Reload Marker Commands\",\r\n            callback: () => this.registerMarkerCommands(true)\r\n        });\r\n\r\n        this.registerMarkerCommands();\r\n        // Register mobile toolbar command for main toggle\r\n        let toolbarTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const toolbarCursorIndex = toolbarTemplate.indexOf(\"{cursor}\");\r\n        let toolbarBefore = \"%%\";\r\n        let toolbarAfter = \"%%\";\r\n        if (toolbarCursorIndex !== -1) {\r\n            toolbarBefore = toolbarTemplate.slice(0, toolbarCursorIndex).trim() || \"%%\";\r\n            toolbarAfter = toolbarTemplate.slice(toolbarCursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        // Compose the label with spaces and a '|' for the cursor\r\n        const toolbarLabel = `${toolbarBefore}${toolbarBefore ? ' ' : ''}|${toolbarAfter ? ' ' : ''}${toolbarAfter}`.trim();\r\n        this.addCommand({\r\n            id: \"toggle-comment-toolbar\",\r\n            name: `Toggle Comment: (${toolbarLabel})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor),\r\n            icon: \"ampersands\",\r\n            mobileOnly: true\r\n        });\r\n        // Removed: auto-cleanup event registration\r\n    }\r\n\r\n    /**\r\n     * Registers all marker commands (main + enabled additional marker sets). If force is true, re-registers all.\r\n     */\r\n    registerMarkerCommands(force = false) {\r\n        if (force && this._markerCommandIds) {\r\n            this._markerCommandIds = [];\r\n        }\r\n        this._markerCommandIds = [];\r\n\r\n        // Register main toggle command\r\n        let mainTemplate = this.settings.template ?? \"%% {cursor} %%\";\r\n        const cursorIndex = mainTemplate.indexOf(\"{cursor}\");\r\n        let before = \"%%\";\r\n        let after = \"%%\";\r\n        if (cursorIndex !== -1) {\r\n            before = mainTemplate.slice(0, cursorIndex).trim() || \"%%\";\r\n            after = mainTemplate.slice(cursorIndex + \"{cursor}\".length).trim() || \"%%\";\r\n        }\r\n        const mainId = \"toggle-comment-template\";\r\n        this.addCommand({\r\n            id: mainId,\r\n            name: `Toggle Comment: (${before}|${after})`,\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n        this._markerCommandIds.push(mainId);\r\n\r\n        // Register additional marker commands if enabled\r\n        if (Array.isArray(this.settings.additionalMarkers)) {\r\n            this.settings.additionalMarkers.forEach((marker, i) => {\r\n                if (marker && marker.registerCommand) {\r\n                    const id = `toggle-comment-marker-set-${i + 1}`;\r\n                    this.addCommand({\r\n                        id,\r\n                        name: (() => {\r\n                            const start = marker.start?.trim() || \"%%\";\r\n                            const end = marker.end?.trim() || \"%%\";\r\n                            return `Toggle Marker ${i + 1}: (${start}|${end})`;\r\n                        })(),\r\n                        checkCallback: (checking: boolean, editor?: Editor) => {\r\n                            if (!checking && editor) this.toggleComment(editor, marker);\r\n                            return true;\r\n                        }\r\n                    });\r\n                    this._markerCommandIds.push(id);\r\n                }\r\n            });\r\n        }\r\n        logDev('Marker commands registered:', this._markerCommandIds);\r\n    }\r\n\r\n    /**\r\n     * Loads plugin settings from disk.\r\n     */\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n        logDev('Settings loaded:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Saves plugin settings to disk.\r\n     */\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n        logDev('Settings saved:', this.settings);\r\n    }\r\n\r\n    /**\r\n     * Reloads the plugin (disable, then enable) using the Obsidian API.\r\n     * Can be called from settings UI to refresh commands after marker set changes.\r\n     */\r\n    async reloadPlugin() {\r\n        // @ts-ignore\r\n        await this.app.plugins.disablePlugin(this.manifest.id);\r\n        // @ts-ignore\r\n        await this.app.plugins.enablePlugin(this.manifest.id);\r\n        logDev('Plugin reloaded');\r\n    }\r\n\r\n    /**\r\n     * Inserts a comment at the current cursor position using the template.\r\n     */\r\n    insertComment(editor: Editor) {\r\n        let template = this.settings.template;\r\n        let cursorIndex = template.indexOf(\"{cursor}\");\r\n        if (cursorIndex === -1) {\r\n            editor.replaceSelection(template);\r\n            logDev('Inserted template (no cursor placeholder)');\r\n            return;\r\n        }\r\n        let before = template.slice(0, cursorIndex).trim();\r\n        let after = template.slice(cursorIndex + \"{cursor}\".length).trim();\r\n        const commentText = `${before} ${after}`.replace(/\\s+/g, ' ').trim();\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(`${before}  ${after}`.replace(/\\s+/g, ' ').replace(' ', ' {cursor} '));\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length + 1;\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n        logDev('Inserted comment at cursor');\r\n    }\r\n\r\n    /**\r\n     * Toggles comment using a specific marker set, or the default template if none provided.\r\n     * Handles selection, word, and cursor modes robustly.\r\n     * @param editor Obsidian editor\r\n     * @param markerSet Optional marker set { start: string; end: string }\r\n     */\r\n    toggleComment(editor: Editor, markerSet?: { start: string; end: string }) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor(), markerSet });\r\n\r\n        // 1. Marker Extraction and Normalization\r\n        let markerStart: string, markerEnd: string;\r\n        if (markerSet) {\r\n            markerStart = markerSet.start.trim();\r\n            markerEnd = markerSet.end.trim();\r\n        } else {\r\n            const template = this.settings.template;\r\n            const cursorIndex = template.indexOf(\"{cursor}\");\r\n            let before = template;\r\n            let after = \"\";\r\n            if (cursorIndex !== -1) {\r\n                before = template.slice(0, cursorIndex);\r\n                after = template.slice(cursorIndex + \"{cursor}\".length);\r\n            }\r\n            markerStart = before.trim();\r\n            markerEnd = after.trim();\r\n        }\r\n        const normStart = normalize(markerStart);\r\n        const normEnd = normalize(markerEnd);\r\n\r\n        // 3.1 Marker Search in Selection\r\n        // --- Advanced Partial Marker Detection ---\r\n        // --- Helper: Search for marker in line in a direction ---\r\n\r\n        // 2. Efficient Comment Detection\r\n        // fallback style detection\r\n\r\n        let wordOnlyMode = this.settings.wordOnlyMode;\r\n        // 3. Mode Decision\r\n        const { from, to, selection } = getSelectionRange(editor);\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let text: string;\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        if (selection) {\r\n            text = selection;\r\n        } else {\r\n            wordBounds = getWordBounds(line, cursor.ch);\r\n            // Only use word bounds if wordOnlyMode is enabled\r\n            if (wordOnlyMode && wordBounds && cursor.ch >= wordBounds.start && cursor.ch <= wordBounds.end) {\r\n                text = line.slice(wordBounds.start, wordBounds.end);\r\n                from.line = cursor.line; from.ch = wordBounds.start;\r\n                to.line = cursor.line; to.ch = wordBounds.end;\r\n            } else {\r\n                text = '';\r\n                // from and to already set to cursor position\r\n            }\r\n        }\r\n\r\n        // Calculate offset in word if cursor is at start, inside, or end of word and wordOnlyMode is enabled\r\n        let offsetInWord = null;\r\n        if (wordOnlyMode && wordBounds && cursor.ch >= wordBounds.start && cursor.ch <= wordBounds.end) {\r\n            offsetInWord = cursor.ch - wordBounds.start;\r\n        }\r\n\r\n        // 4. Comment Region Detection\r\n        let startIdx = -1, endIdx = -1;\r\n        let region = '', regionIsComment = false;\r\n        let usedStart = normStart, usedEnd = normEnd;\r\n        let uniqueMarkers = Boolean(usedStart && usedEnd && usedStart !== usedEnd);\r\n        // --- Detection Logging ---\r\n        logDev('[Detection] selection:', selection);\r\n        logDev('[Detection] text:', text);\r\n        const foundStart = findMarkerInText(normStart, text);\r\n        const foundEnd = findMarkerInText(normEnd, text);\r\n        logDev('[Detection] foundStart:', foundStart);\r\n        logDev('[Detection] foundEnd:', foundEnd);\r\n        // Always run toggling logic, even for just a cursor\r\n        // Find all start and end marker positions in the entire document\r\n        const markerStarts = [];\r\n        const markerEnds = [];\r\n        const lineCount = editor.lineCount();\r\n        for (let i = 0; i < lineCount; i++) {\r\n            const lineText = editor.getLine(i);\r\n            let idx = 0;\r\n            while ((idx = lineText.indexOf(normStart, idx)) !== -1) {\r\n                markerStarts.push({ line: i, ch: idx });\r\n                idx += normStart.length;\r\n            }\r\n            idx = 0;\r\n            while ((idx = lineText.indexOf(normEnd, idx)) !== -1) {\r\n                markerEnds.push({ line: i, ch: idx });\r\n                idx += normEnd.length;\r\n            }\r\n        }\r\n        // Find the marker pair that encompasses the selection (fully or partially overlaps)\r\n        let pairToRemove = null;\r\n        // Use stack to ensure correct matching of start/end pairs\r\n        const stack: { line: number, ch: number }[] = [];\r\n        for (let i = 0, s = 0, e = 0; i < markerStarts.length + markerEnds.length;) {\r\n            let nextStart = s < markerStarts.length ? markerStarts[s] : null;\r\n            let nextEnd = e < markerEnds.length ? markerEnds[e] : null;\r\n            let isStart = false;\r\n            if (nextStart && (!nextEnd || nextStart.line < nextEnd.line || (nextStart.line === nextEnd.line && nextStart.ch < nextEnd.ch))) {\r\n                stack.push(nextStart);\r\n                s++;\r\n                isStart = true;\r\n            } else if (nextEnd) {\r\n                if (stack.length > 0) {\r\n                    const start = stack.pop();\r\n                    if (start) { // Type guard for start\r\n                        const end = nextEnd;\r\n                        // Marker region\r\n                        const markerRegionStart = { line: start.line, ch: start.ch };\r\n                        const markerRegionEnd = { line: end.line, ch: end.ch + normEnd.length };\r\n                        // Selection must be fully or partially within the marker region (overlap)\r\n                        const selStart = from;\r\n                        const selEnd = to;\r\n                        const selectionWithinMarker =\r\n                            (selStart.line < markerRegionEnd.line || (selStart.line === markerRegionEnd.line && selStart.ch < markerRegionEnd.ch)) &&\r\n                            (selEnd.line > markerRegionStart.line || (selEnd.line === markerRegionStart.line && selEnd.ch > markerRegionStart.ch));\r\n                        const selectionCompletelyBefore =\r\n                            (selEnd.line < markerRegionStart.line) ||\r\n                            (selEnd.line === markerRegionStart.line && selEnd.ch <= markerRegionStart.ch);\r\n                        const selectionCompletelyAfter =\r\n                            (selStart.line > markerRegionEnd.line) ||\r\n                            (selStart.line === markerRegionEnd.line && selStart.ch >= markerRegionEnd.ch);\r\n                        if (selectionWithinMarker && !selectionCompletelyBefore && !selectionCompletelyAfter) {\r\n                            pairToRemove = { start, end };\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                e++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if (pairToRemove) {\r\n            // Remove the marker pair in a single transaction so undo restores both\r\n            const { start, end } = pairToRemove;\r\n            let startSpace = 0;\r\n            const startLineText = editor.getLine(start.line);\r\n            if (startLineText[start.ch + normStart.length] === ' ') {\r\n                startSpace = 1;\r\n            }\r\n            let endSpace = 0;\r\n            const endLineText = editor.getLine(end.line);\r\n            if (end.ch > 0 && endLineText[end.ch - 1] === ' ') {\r\n                endSpace = 1;\r\n            }\r\n            // Count all marker removals before selection start/end on their lines\r\n            let removedBeforeStart = 0;\r\n            let removedBeforeEnd = 0;\r\n            // Check start marker on selection start line\r\n            if (start.line === from.line && start.ch < from.ch) {\r\n                removedBeforeStart += normStart.length + startSpace;\r\n            }\r\n            // Check end marker on selection start line (rare, but possible)\r\n            if (end.line === from.line && end.ch < from.ch) {\r\n                removedBeforeStart += normEnd.length + endSpace;\r\n            }\r\n            // Check start marker on selection end line\r\n            if (start.line === to.line && start.ch < to.ch) {\r\n                removedBeforeEnd += normStart.length + startSpace;\r\n            }\r\n            // Check end marker on selection end line\r\n            if (end.line === to.line && end.ch < to.ch) {\r\n                removedBeforeEnd += normEnd.length + endSpace;\r\n            }\r\n            editor.transaction({\r\n                changes: [\r\n                    { from: { line: end.line, ch: end.ch - endSpace }, to: { line: end.line, ch: end.ch + normEnd.length }, text: '' },\r\n                    { from: { line: start.line, ch: start.ch }, to: { line: start.line, ch: start.ch + normStart.length + startSpace }, text: '' }\r\n                ]\r\n            });\r\n            // Adjust selection or cursor\r\n            let selFrom = { ...from };\r\n            let selTo = { ...to };\r\n            if (removedBeforeStart && selFrom.line === from.line) {\r\n                selFrom.ch = Math.max(0, selFrom.ch - removedBeforeStart);\r\n            }\r\n            if (removedBeforeEnd && selTo.line === to.line) {\r\n                selTo.ch = Math.max(selFrom.ch, selTo.ch - removedBeforeEnd);\r\n            }\r\n            logDev('Uncommented marker pair encompassing selection', { from, to, pairToRemove, removedBeforeStart, removedBeforeEnd, selFrom, selTo });\r\n            // If just a cursor or word under cursor, set cursor (no selection), else set selection\r\n            if ((from.line === to.line && from.ch === to.ch) || (wordBounds && from.line === to.line && from.ch === wordBounds?.start && to.ch === wordBounds?.end)) {\r\n                // Place cursor at original offset within the word/text, accounting for removed chars before cursor\r\n                let cursorCh;\r\n                if (offsetInWord !== null && wordBounds) {\r\n                    // Place at same offset in word after uncommenting\r\n                    cursorCh = wordBounds.start + offsetInWord - (removedBeforeStart || 0);\r\n                } else {\r\n                    cursorCh = from.ch - (removedBeforeStart || 0);\r\n                }\r\n                editor.setCursor({ line: from.line, ch: Math.max(0, cursorCh) });\r\n            } else {\r\n                editor.setSelection(selFrom, selTo);\r\n            }\r\n            return;\r\n        }\r\n        // If no marker pair was found, wrap the selection or cursor in a comment and return\r\n        const selText = editor.getRange(from, to);\r\n        // Always add a space after start and before end, even for cursor only\r\n        const commented = normStart + ' ' + selText + ' ' + normEnd;\r\n        editor.replaceRange(commented, from, to);\r\n        const startMarkerLen = normStart.length + 1; // +1 for space after start\r\n        if ((from.line === to.line && from.ch === to.ch) || (wordBounds && from.line === to.line && from.ch === wordBounds.start && to.ch === wordBounds.end)) {\r\n            // Cursor only or word under cursor: place cursor at same offset in word as before\r\n            let cursorCh;\r\n            if (offsetInWord !== null) {\r\n                cursorCh = from.ch + startMarkerLen + offsetInWord;\r\n            } else {\r\n                cursorCh = from.ch + startMarkerLen;\r\n            }\r\n            editor.setCursor({ line: from.line, ch: cursorCh });\r\n        } else {\r\n            // Selection: select the commented region\r\n            const selFrom = { line: from.line, ch: from.ch + startMarkerLen };\r\n            let selTo;\r\n            if (from.line === to.line) {\r\n                selTo = { line: to.line, ch: to.ch + startMarkerLen };\r\n            } else {\r\n                selTo = { line: to.line, ch: to.ch };\r\n            }\r\n            editor.setSelection(selFrom, selTo);\r\n        }\r\n        logDev('Commented region (no marker pair found)', { from, to, commented });\r\n        return;\r\n\r\n        // 5. Toggle Logic\r\n        if (regionIsComment) {\r\n            let beforeRegion = line.slice(0, startIdx);\r\n            let afterRegion = line.slice((usedEnd && endIdx !== -1 ? endIdx + usedEnd.length : line.length));\r\n            let startMarkerExtra = 0;\r\n            if (region.startsWith(' ')) {\r\n                region = region.slice(1);\r\n                startMarkerExtra = 1;\r\n            }\r\n            let endMarkerExtra = 0;\r\n            if (region.endsWith(' ')) {\r\n                region = region.slice(0, -1);\r\n                endMarkerExtra = 1;\r\n            }\r\n            let newLine = beforeRegion + region + afterRegion;\r\n            editor.setLine(cursor.line, newLine);\r\n            if (selection) {\r\n                let selFromCh = from.ch;\r\n                let selToCh = to.ch;\r\n                if (from.ch <= startIdx + usedStart.length + startMarkerExtra) {\r\n                    selFromCh = startIdx;\r\n                } else {\r\n                    selFromCh = from.ch - usedStart.length + startMarkerExtra;\r\n                }\r\n                if (usedEnd && endIdx !== -1 && to.ch >= endIdx) {\r\n                    selToCh = startIdx + region.length;\r\n                } else {\r\n                    selToCh = to.ch - usedStart.length + startMarkerExtra;\r\n                }\r\n                selFromCh = Math.max(0, selFromCh);\r\n                selToCh = Math.max(selFromCh, selToCh);\r\n                const selFrom = { line: cursor.line, ch: selFromCh };\r\n                const selTo = { line: cursor.line, ch: selToCh };\r\n                editor.setSelection(selFrom, selTo);\r\n                logDev('Uncommented region', { from, to, region });\r\n            } else {\r\n                return;\r\n            }\r\n        } else {\r\n            if (selection) {\r\n                const selText = editor.getRange(from, to);\r\n                const commented = usedStart + (selText ? ' ' : '') + selText + (selText ? ' ' : '') + usedEnd;\r\n                editor.replaceRange(commented, from, to);\r\n                const startMarkerLen = usedStart.length + (selText ? 1 : 0);\r\n                const endMarkerLen = usedEnd.length + (selText ? 1 : 0);\r\n                const selFrom = { line: from.line, ch: from.ch + startMarkerLen };\r\n                let selTo;\r\n                if (from.line === to.line) {\r\n                    selTo = { line: to.line, ch: to.ch + startMarkerLen };\r\n                } else {\r\n                    selTo = { line: to.line, ch: to.ch };\r\n                }\r\n                editor.setSelection(selFrom, selTo);\r\n                logDev('Commented region', { from, to, commented });\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx + markerEnd.length;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface MarkerSet {\r\n    start: string;\r\n    end: string;\r\n    registerCommand?: boolean;\r\n}\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n    additionalMarkers?: Array<MarkerSet>;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false,\r\n    additionalMarkers: []\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addText(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        // Additional marker sets UI\r\n        containerEl.createEl('h3', { text: 'Additional Marker Sets' });\r\n        const additionalMarkers = this.plugin.settings.additionalMarkers || [];\r\n        additionalMarkers.forEach((marker, idx) => {\r\n            const setting = new Setting(containerEl)\r\n                .setName(`Marker Set ${idx + 1}`)\r\n                // Add toggle for command registration\r\n                .addToggle(toggle => toggle\r\n                    .setValue(!!marker.registerCommand)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].registerCommand = value;\r\n                            await this.plugin.saveSettings();\r\n                            this.plugin.registerMarkerCommands(true); // Update commands in-place, do not reload plugin\r\n                            this.display(); // Only refresh UI on toggle\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('Start marker')\r\n                    .setValue(marker.start)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].start = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addText(text => text\r\n                    .setPlaceholder('End marker')\r\n                    .setValue(marker.end)\r\n                    .onChange(async (value) => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers[idx].end = value;\r\n                            await this.plugin.saveSettings();\r\n                            // Do not call this.display() here to avoid focus loss\r\n                        }\r\n                    })\r\n                )\r\n                .addExtraButton(btn => btn\r\n                    .setIcon('cross')\r\n                    .setTooltip('Remove marker set')\r\n                    .onClick(async () => {\r\n                        if (this.plugin.settings.additionalMarkers) {\r\n                            this.plugin.settings.additionalMarkers.splice(idx, 1);\r\n                            await this.plugin.saveSettings();\r\n                            this.display(); // Only refresh UI on remove\r\n                        }\r\n                    })\r\n                );\r\n        });\r\n        new Setting(containerEl)\r\n            .addButton(btn => btn\r\n                .setButtonText('Add Marker Set')\r\n                .setCta()\r\n                .onClick(async () => {\r\n                    if (!this.plugin.settings.additionalMarkers) this.plugin.settings.additionalMarkers = [];\r\n                    this.plugin.settings.additionalMarkers.push({ start: '', end: '', registerCommand: false });\r\n                    await this.plugin.saveSettings();\r\n                    this.display(); // Only refresh UI on add\r\n                })\r\n            );\r\n    }\r\n}\r\n", "// Utility: Normalize a marker string (collapse whitespace, trim)\r\nexport function normalize(str: string): string {\r\n    return str.replace(/\\s+/g, ' ').trim();\r\n}\r\n", "// Find a marker in a text, return index and match info\r\nexport function findMarkerInText(marker: string, text: string) {\r\n    let idx = text.indexOf(marker);\r\n    if (idx !== -1) return { idx, full: true };\r\n    // Try partials (from length-1 down to 1)\r\n    for (let len = marker.length - 1; len > 0; len--) {\r\n        if (text.includes(marker.slice(0, len))) return { idx: text.indexOf(marker.slice(0, len)), full: false, partial: marker.slice(0, len) };\r\n        if (text.includes(marker.slice(-len))) return { idx: text.indexOf(marker.slice(-len)), full: false, partial: marker.slice(-len) };\r\n    }\r\n    return { idx: -1, full: false };\r\n}\r\n", "// Get word bounds in a line at a given character position\r\nexport function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n    const regex = /[\\p{L}\\p{N}_]+/gu;\r\n    let match;\r\n    while ((match = regex.exec(line)) !== null) {\r\n        if (ch >= match.index && ch <= match.index + match[0].length) {\r\n            return { start: match.index, end: match.index + match[0].length };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n", "import { Editor } from \"obsidian\";\r\n\r\n/**\r\n * Returns the selection range from the editor, or treats the cursor as a zero-width selection if no selection exists.\r\n * @param editor Obsidian editor instance\r\n * @returns { from, to, selection }\r\n */\r\nexport function getSelectionRange(editor: Editor) {\r\n    const selection = editor.getSelection();\r\n    if (selection) {\r\n        return {\r\n            from: editor.getCursor(\"from\"),\r\n            to: editor.getCursor(\"to\"),\r\n            selection,\r\n        };\r\n    } else {\r\n        const cursor = editor.getCursor();\r\n        return {\r\n            from: { line: cursor.line, ch: cursor.ch },\r\n            to: { line: cursor.line, ch: cursor.ch },\r\n            selection: '',\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "marker", "idx", "setting", "btn", "normalize", "str", "findMarkerInText", "marker", "text", "idx", "len", "getWordBounds", "line", "ch", "regex", "match", "getSelectionRange", "editor", "selection", "cursor", "logDev", "args", "CommentFormatPlugin", "logDev", "CommentFormatSettingTab", "toolbarTemplate", "toolbarCursorIndex", "toolbarBefore", "toolbarAfter", "toolbarLabel", "editor", "force", "mainTemplate", "cursorIndex", "before", "after", "mainId", "marker", "i", "id", "start", "end", "checking", "DEFAULT_SETTINGS", "template", "commentText", "from", "lines", "cursorLineOffset", "cursorChOffset", "markerSet", "markerStart", "markerEnd", "normStart", "normalize", "normEnd", "wordOnlyMode", "to", "selection", "getSelectionRange", "cursor", "line", "text", "wordBounds", "getWordBounds", "offsetInWord", "startIdx", "endIdx", "region", "regionIsComment", "usedStart", "usedEnd", "uniqueMarkers", "foundStart", "findMarkerInText", "foundEnd", "markerStarts", "markerEnds", "lineCount", "lineText", "idx", "pairToRemove", "stack", "s", "e", "nextStart", "nextEnd", "isStart", "markerRegionStart", "markerRegionEnd", "selStart", "selEnd", "selectionWithinMarker", "selectionCompletelyBefore", "selectionCompletelyAfter", "startSpace", "endSpace", "endLineText", "removedBeforeStart", "removedBeforeEnd", "selFrom", "selTo", "cursorCh", "selText", "commented", "startMarkerLen", "clampCursorPos", "pos", "allLines", "ch", "isInside", "uncommented"]
}
