{
  "version": 3,
  "sources": ["../src/main.ts", "../src/settingsData.ts", "../src/settingsTab.ts"],
  "sourcesContent": ["/**\r\n * Main entry point for the Custom Comments Obsidian plugin.\r\n *\r\n * This plugin allows users to insert customizable comment templates into their notes.\r\n * Users can define their own comment format using `{cursor}` as a placeholder for the cursor position.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport { Plugin, Editor } from \"obsidian\";\r\nimport { CommentFormatSettings, DEFAULT_SETTINGS } from \"./settingsData\";\r\nimport { CommentFormatSettingTab } from \"./settingsTab\";\r\n\r\n// DEV logging utility: only logs if __DEV__ is true (set by esbuild)\r\ndeclare const __DEV__: boolean;\r\nfunction logDev(...args: any[]) {\r\n    if (typeof __DEV__ !== 'undefined' && __DEV__) {\r\n        // eslint-disable-next-line no-console\r\n        console.log('[CustomComment DEV]', ...args);\r\n    }\r\n}\r\n\r\nexport default class CommentFormatPlugin extends Plugin {\r\n    /**\r\n     * Plugin settings, loaded on initialization.\r\n     */\r\n    settings!: CommentFormatSettings & { wordOnlyMode?: boolean };\r\n\r\n    async onload() {\r\n        await this.loadSettings();\r\n        this.addSettingTab(new CommentFormatSettingTab(this.app, this));\r\n\r\n        this.addCommand({\r\n            id: \"toggle-comment-template\",\r\n            name: \"Toggle Comment\",\r\n            editorCallback: (editor: Editor) => this.toggleComment(editor)\r\n        });\r\n    }\r\n\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n    }\r\n\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n    }\r\n\r\n    insertComment(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n\r\n        if (cursorIndex === -1) {\r\n            // Fallback: insert template and move cursor to start\r\n            editor.replaceSelection(template);\r\n            return;\r\n        }\r\n\r\n        // Remove {cursor} and track where it was\r\n        const before = template.slice(0, cursorIndex);\r\n        const after = template.slice(cursorIndex + \"{cursor}\".length);\r\n\r\n        const from = editor.getCursor();\r\n        editor.replaceSelection(before + after);\r\n\r\n        // Calculate the new cursor position\r\n        const lines = before.split(\"\\n\");\r\n        const cursorLineOffset = lines.length - 1;\r\n        const cursorChOffset = lines[lines.length - 1].length;\r\n\r\n        editor.setCursor({\r\n            line: from.line + cursorLineOffset,\r\n            ch: (cursorLineOffset ? 0 : from.ch) + cursorChOffset\r\n        });\r\n    }\r\n\r\n    toggleComment(editor: Editor) {\r\n        logDev('toggleComment called', { selection: editor.getSelection(), cursor: editor.getCursor() });\r\n        // --- Clamp helper ---\r\n        function clampCursorPos(pos: { line: number, ch: number }): { line: number, ch: number } {\r\n            const allLines = editor.getValue().split('\\n');\r\n            let line = Math.max(0, Math.min(pos.line, allLines.length - 1));\r\n            let ch = Math.max(0, Math.min(pos.ch, allLines[line]?.length ?? 0));\r\n            return { line, ch };\r\n        }\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before;\r\n        const markerEnd = after;\r\n        const defaultStyles = [\r\n            { start: \"%%\", end: \"%%\" },\r\n            { start: \"<!--\", end: \"-->\" },\r\n            { start: \"//\", end: \"\" },\r\n        ];\r\n        const selection = editor.getSelection();\r\n        const cursor = editor.getCursor();\r\n        let text: string;\r\n        let from = editor.getCursor(\"from\");\r\n        let to = editor.getCursor(\"to\");\r\n        let wordBounds: { start: number, end: number } | null = null;\r\n        let line = editor.getLine(cursor.line);\r\n        // Helper to find word bounds at a given ch, ignoring punctuation\r\n        function getWordBounds(line: string, ch: number): { start: number, end: number } | null {\r\n            // Only match sequences of letters, numbers, or underscores (ignore punctuation)\r\n            const regex = /[\\p{L}\\p{N}_]+/gu;\r\n            let match;\r\n            while ((match = regex.exec(line)) !== null) {\r\n                if (ch >= match.index && ch <= match.index + match[0].length) {\r\n                    return { start: match.index, end: match.index + match[0].length };\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        function isTextCommentedExact(str: string, start: string, end: string) {\r\n            if (!start) return false;\r\n            if (end) {\r\n                return str.startsWith(start) && str.endsWith(end);\r\n            } else {\r\n                return str.startsWith(start);\r\n            }\r\n        }\r\n        // Utility: Scan lines in a direction for a marker, stopping if the opposite marker is found first\r\n        function scanForFirst(lines: string[], fromLine: number, fromCh: number, marker: string, opposite: string, direction: 'back' | 'forward'): { type: 'marker' | 'opposite' | null, pos: { line: number, ch: number } | null } {\r\n            // Remove leading/trailing whitespace for marker matching\r\n            const markerTrim = marker.trim();\r\n            const oppositeTrim = opposite.trim();\r\n            if (direction === 'back') {\r\n                for (let l = fromLine; l >= 0; l--) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : line.length;\r\n                    for (let idx = searchStart - 1; idx >= 0; idx--) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            } else {\r\n                for (let l = fromLine; l < lines.length; l++) {\r\n                    let line = lines[l];\r\n                    let searchStart = l === fromLine ? fromCh : 0;\r\n                    for (let idx = searchStart; idx <= line.length - Math.min(markerTrim.length, oppositeTrim.length); idx++) {\r\n                        if (line.substr(idx, markerTrim.length) === markerTrim) return { type: 'marker', pos: { line: l, ch: idx } };\r\n                        if (line.substr(idx, oppositeTrim.length) === oppositeTrim) return { type: 'opposite', pos: { line: l, ch: idx } };\r\n                    }\r\n                }\r\n            }\r\n            return { type: null, pos: null };\r\n        }\r\n        // Main logic for comment detection\r\n        let isComment = false;\r\n        let commentStartPos: { line: number, ch: number } | null = null;\r\n        let commentEndPos: { line: number, ch: number } | null = null;\r\n        const allLines = editor.getValue().split('\\n');\r\n        if (markerStart && markerEnd) {\r\n            let beforeType, afterType;\r\n            if (selection) {\r\n                const before = scanForFirst(allLines, from.line, from.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, to.line, to.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            } else {\r\n                const before = scanForFirst(allLines, cursor.line, cursor.ch, markerStart, markerEnd, 'back');\r\n                const after = scanForFirst(allLines, cursor.line, cursor.ch, markerEnd, markerStart, 'forward');\r\n                beforeType = before.type;\r\n                afterType = after.type;\r\n                if (beforeType === 'marker') commentStartPos = before.pos;\r\n                if (afterType === 'marker') commentEndPos = after.pos;\r\n            }\r\n            if (beforeType === 'marker' && afterType === 'marker') {\r\n                isComment = true;\r\n            } else if (beforeType === 'opposite' && afterType === 'opposite') {\r\n                isComment = false;\r\n            } else {\r\n                isComment = false;\r\n            }\r\n        }\r\n        // Log with 1-based line/ch for user clarity\r\n        logDev('comment:', isComment, {\r\n            start: commentStartPos ? { line: commentStartPos.line + 1, ch: commentStartPos.ch + 1 } : null,\r\n            end: commentEndPos ? { line: commentEndPos.line + 1, ch: commentEndPos.ch + 1 } : null\r\n        });\r\n        // If isComment is true, remove the detected markers\r\n        if (isComment && commentStartPos && commentEndPos) {\r\n            // Remove start marker (match full marker, not trimmed)\r\n            let startLine = allLines[commentStartPos.line];\r\n            allLines[commentStartPos.line] = startLine.slice(0, commentStartPos.ch) + startLine.slice(commentStartPos.ch + markerStart.length);\r\n            // Adjust end marker position if on same line as start\r\n            let endLineIdx = commentEndPos.line;\r\n            let endChIdx = commentEndPos.ch;\r\n            if (commentStartPos.line === commentEndPos.line) {\r\n                endChIdx -= markerStart.length;\r\n            }\r\n            // Remove end marker (match full marker, not trimmed)\r\n            let endLine = allLines[endLineIdx];\r\n            // Remove any single space immediately before the end marker (to avoid trailing space)\r\n            let spaceAdjust = 0;\r\n            if (endChIdx > 0 && endLine[endChIdx - 1] === ' ') {\r\n                endChIdx--;\r\n                spaceAdjust = 1;\r\n            }\r\n            allLines[endLineIdx] = endLine.slice(0, endChIdx) + endLine.slice(endChIdx + markerEnd.length);\r\n            // Replace the affected lines in the editor\r\n            const fromLine = Math.min(commentStartPos.line, commentEndPos.line);\r\n            const toLine = Math.max(commentStartPos.line, commentEndPos.line);\r\n            const newText = allLines.slice(fromLine, toLine + 1).join('\\n');\r\n            editor.replaceRange(newText, { line: fromLine, ch: 0 }, { line: toLine, ch: editor.getLine(toLine).length });\r\n            // Adjust cursor position: keep it at the same logical place after removing start marker\r\n            let newCursorLine = from.line;\r\n            let newCursorCh = from.ch - markerStart.length;\r\n            if (newCursorCh < 0) newCursorCh = 0;\r\n            // If cursor would be outside the document, clamp to end\r\n            const lastLine = allLines.length - 1;\r\n            if (newCursorLine > lastLine) newCursorLine = lastLine;\r\n            let lineLen = allLines[newCursorLine]?.length ?? 0;\r\n            if (newCursorCh > lineLen) newCursorCh = lineLen;\r\n            // If the calculated line/ch is outside the document, set to very end\r\n            let clamped = clampCursorPos({ line: newCursorLine, ch: newCursorCh });\r\n            editor.setCursor(clamped);\r\n            return;\r\n        }\r\n        // Decide word or insert-at-cursor mode\r\n        let useWord = false;\r\n        wordBounds = getWordBounds(line, cursor.ch);\r\n        if (selection) {\r\n            useWord = false;\r\n        } else if (wordBounds) {\r\n            // Cursor is inside a word\r\n            if (cursor.ch > wordBounds.start && cursor.ch < wordBounds.end) {\r\n                // Always operate on the word if cursor is inside the word (not at boundary)\r\n                useWord = true;\r\n            } else if (this.settings.wordOnlyMode && (cursor.ch === wordBounds.start || cursor.ch === wordBounds.end)) {\r\n                // Only operate on the word at boundary if wordOnlyMode is enabled\r\n                useWord = true;\r\n            } else {\r\n                // At word boundary and wordOnlyMode is off: insert at cursor\r\n                useWord = false;\r\n            }\r\n        }\r\n        logDev('Mode:', selection ? 'selection' : useWord ? 'word' : 'insert', { selection, wordBounds, useWord });\r\n        // Determine text and range\r\n        if (selection) {\r\n            text = selection;\r\n        } else if (useWord && wordBounds) {\r\n            text = line.slice(wordBounds.start, wordBounds.end);\r\n            from = { line: cursor.line, ch: wordBounds.start };\r\n            to = { line: cursor.line, ch: wordBounds.end };\r\n        } else {\r\n            text = '';\r\n            from = { line: cursor.line, ch: cursor.ch };\r\n            to = { line: cursor.line, ch: cursor.ch };\r\n        }\r\n        // Remove block comment logic (findBlockCommentBounds) as it is not needed for the new comment detection\r\n        // Check if selection or word/line is inside a comment (custom or default)\r\n        // --- Removal takes priority ---\r\n        let removalUsedStart = before;\r\n        let removalUsedEnd = after;\r\n        let removalInside = false;\r\n        let removalCheckText = text;\r\n        if (selection) {\r\n            if (removalUsedStart && removalUsedEnd && selection.startsWith(removalUsedStart) && selection.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = selection;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && selection.startsWith(style.start) && selection.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = selection;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside) {\r\n                const lineStart = editor.getLine(from.line);\r\n                const lineEnd = editor.getLine(to.line);\r\n                if (removalUsedStart && removalUsedEnd && lineStart.startsWith(removalUsedStart) && lineEnd.endsWith(removalUsedEnd)) {\r\n                    removalInside = true;\r\n                    removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                } else {\r\n                    for (const style of defaultStyles) {\r\n                        if (style.start && style.end && lineStart.startsWith(style.start) && lineEnd.endsWith(style.end)) {\r\n                            removalUsedStart = style.start;\r\n                            removalUsedEnd = style.end;\r\n                            removalInside = true;\r\n                            removalCheckText = editor.getRange({ line: from.line, ch: 0 }, { line: to.line, ch: editor.getLine(to.line).length });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (useWord && wordBounds) {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!removalInside && removalUsedStart && removalUsedEnd && text.startsWith(removalUsedStart) && text.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = text;\r\n            } else if (!removalInside) {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && text.startsWith(style.start) && text.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = text;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (removalUsedStart && removalUsedEnd && line.startsWith(removalUsedStart) && line.endsWith(removalUsedEnd)) {\r\n                removalInside = true;\r\n                removalCheckText = line;\r\n            } else {\r\n                for (const style of defaultStyles) {\r\n                    if (style.start && style.end && line.startsWith(style.start) && line.endsWith(style.end)) {\r\n                        removalUsedStart = style.start;\r\n                        removalUsedEnd = style.end;\r\n                        removalInside = true;\r\n                        removalCheckText = line;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Remove the nearest comment markers before/after the word or selection\r\n        function removeNearestMarkersFromWordOrSelection(text: string, start: string, end: string, selectionStart: number, selectionEnd: number): { result: string, newStart: number, newEnd: number } {\r\n            // No-op: marker removal logic removed as requested\r\n            return { result: text, newStart: selectionStart, newEnd: selectionEnd };\r\n        }\r\n        if (removalInside) {\r\n            // No-op: skip marker removal entirely\r\n            return;\r\n        }\r\n        // Check if text/word/selection is commented\r\n        let usedStart = markerStart;\r\n        let usedEnd = markerEnd;\r\n        let inside = false;\r\n        let checkText = text;\r\n        if (selection) {\r\n            checkText = text;\r\n        } else if (useWord && wordBounds) {\r\n            checkText = line.slice(wordBounds.start, wordBounds.end);\r\n        } else {\r\n            checkText = text;\r\n        }\r\n        if (usedStart && isTextCommentedExact(checkText, usedStart, usedEnd)) {\r\n            inside = true;\r\n        } else {\r\n            for (const style of defaultStyles) {\r\n                if (style.start && isTextCommentedExact(checkText, style.start, style.end)) {\r\n                    usedStart = style.start;\r\n                    usedEnd = style.end;\r\n                    inside = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (inside) {\r\n            logDev('Removing exact comment markers', { usedStart, usedEnd, checkText });\r\n            // Remove comment markers (exact, not trimmed)\r\n            let uncommented = checkText;\r\n            let removedStartLen = 0;\r\n            if (usedStart && uncommented.startsWith(usedStart)) {\r\n                removedStartLen = usedStart.length;\r\n                uncommented = uncommented.slice(usedStart.length);\r\n            }\r\n            if (usedEnd && uncommented.endsWith(usedEnd)) {\r\n                uncommented = uncommented.slice(0, -usedEnd.length);\r\n            }\r\n            if (selection) {\r\n                editor.replaceSelection(uncommented);\r\n                const selFrom = clampCursorPos(from);\r\n                const selTo = clampCursorPos({ line: to.line, ch: to.ch - removedStartLen });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(uncommented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = Math.max(wordBounds.start, cursor.ch - removedStartLen);\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                editor.replaceRange(uncommented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch });\r\n                editor.setCursor(clamped);\r\n            }\r\n        } else {\r\n            logDev('Adding comment markers', { markerStart, markerEnd, text });\r\n            // Add comment markers, preserving template spaces\r\n            let commented = markerStart + text + markerEnd;\r\n            if (selection) {\r\n                editor.replaceSelection(commented);\r\n                const startOffset = markerStart.length;\r\n                const selFrom = clampCursorPos({ line: from.line, ch: from.ch + startOffset });\r\n                const selTo = clampCursorPos({ line: to.line, ch: to.ch + startOffset });\r\n                editor.setSelection(selFrom, selTo);\r\n            } else if (useWord && wordBounds) {\r\n                editor.replaceRange(commented, { line: cursor.line, ch: wordBounds.start }, { line: cursor.line, ch: wordBounds.end });\r\n                const newCh = cursor.ch + markerStart.length;\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: newCh });\r\n                editor.setCursor(clamped);\r\n            } else {\r\n                // Insert at cursor\r\n                editor.replaceRange(commented, { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });\r\n                const clamped = clampCursorPos({ line: cursor.line, ch: cursor.ch + markerStart.length });\r\n                editor.setCursor(clamped);\r\n            }\r\n        }\r\n        // After inserting, clamp cursor to end of document if needed\r\n        const finalCursor = clampCursorPos(editor.getCursor());\r\n        if (finalCursor.line !== editor.getCursor().line || finalCursor.ch !== editor.getCursor().ch) {\r\n            editor.setCursor(finalCursor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles the comment if the cursor is within a comment marked by the custom markers.\r\n     * If the cursor/selection is inside a comment, removes the markers. Otherwise, does nothing.\r\n     */\r\n    toggleCommentAtCursor(editor: Editor) {\r\n        const template = this.settings.template;\r\n        const cursorIndex = template.indexOf(\"{cursor}\");\r\n        let before = template;\r\n        let after = \"\";\r\n        if (cursorIndex !== -1) {\r\n            before = template.slice(0, cursorIndex);\r\n            after = template.slice(cursorIndex + \"{cursor}\".length);\r\n        }\r\n        const markerStart = before.trim();\r\n        const markerEnd = after.trim();\r\n\r\n        const cursor = editor.getCursor();\r\n        let line = editor.getLine(cursor.line);\r\n        let startIdx = line.indexOf(markerStart);\r\n        let endIdx = markerEnd ? line.lastIndexOf(markerEnd) : -1;\r\n        let isInside = false;\r\n        if (markerStart && markerEnd) {\r\n            isInside = startIdx !== -1 && endIdx !== -1 && cursor.ch >= startIdx + markerStart.length && cursor.ch <= endIdx;\r\n        } else if (markerStart) {\r\n            isInside = startIdx !== -1 && cursor.ch >= startIdx + markerStart.length;\r\n        }\r\n        if (isInside) {\r\n            // Remove markers from the line\r\n            let uncommented = line;\r\n            if (markerStart) {\r\n                uncommented = uncommented.replace(markerStart, \"\");\r\n            }\r\n            if (markerEnd) {\r\n                uncommented = uncommented.replace(markerEnd, \"\");\r\n            }\r\n            uncommented = uncommented.trim();\r\n            editor.setLine(cursor.line, uncommented);\r\n        }\r\n    }\r\n}", "/**\r\n * Settings interface and default values for the Custom Comments plugin.\r\n *\r\n * @interface CommentFormatSettings\r\n * @property {string} template - The comment template string, with `{cursor}` as the cursor placeholder.\r\n *\r\n * @constant DEFAULT_SETTINGS - Default settings for the plugin.\r\n */\r\n\r\nexport interface CommentFormatSettings {\r\n    template: string;\r\n    wordOnlyMode?: boolean;\r\n}\r\n\r\nexport const DEFAULT_SETTINGS: CommentFormatSettings = {\r\n    template: \"%% {cursor} %%\",\r\n    wordOnlyMode: false\r\n};\r\n", "/**\r\n * Settings tab for the Custom Comments plugin.\r\n *\r\n * This class creates the settings UI in Obsidian's settings panel, allowing users to customize their comment template.\r\n *\r\n * @class CommentFormatSettingTab\r\n * @extends PluginSettingTab\r\n */\r\nimport { App, PluginSettingTab, Setting } from \"obsidian\";\r\nimport CommentFormatPlugin from \"./main\";\r\n\r\nexport class CommentFormatSettingTab extends PluginSettingTab {\r\n    plugin: CommentFormatPlugin;\r\n\r\n    constructor(app: App, plugin: CommentFormatPlugin) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n        containerEl.empty();\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Comment Format\")\r\n            .setDesc(\"Use {cursor} wherever you want the cursor to go (e.g. '%% {cursor} %%' or '<!-- {cursor} -->').\")\r\n            .addTextArea(text =>\r\n                text\r\n                    .setValue(this.plugin.settings.template)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.template = value || \"%% {cursor} %%\";\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n\r\n        new Setting(containerEl)\r\n            .setName(\"Word-only toggle mode\")\r\n            .setDesc(\"If enabled, toggling will un/comment the word at the cursor's location rather than inserting a comment at the cursor position.\")\r\n            .addToggle(toggle =>\r\n                toggle\r\n                    .setValue(!!this.plugin.settings.wordOnlyMode)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.wordOnlyMode = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["main_exports", "__export", "CommentFormatPlugin", "__toCommonJS", "import_obsidian", "DEFAULT_SETTINGS", "import_obsidian", "CommentFormatSettingTab", "app", "plugin", "containerEl", "text", "value", "toggle", "logDev", "args", "CommentFormatPlugin", "CommentFormatSettingTab", "editor", "DEFAULT_SETTINGS", "template", "cursorIndex", "before", "after", "from", "lines", "cursorLineOffset", "cursorChOffset", "clampCursorPos", "pos", "allLines", "line", "ch", "markerStart", "markerEnd", "defaultStyles", "selection", "cursor", "text", "to", "wordBounds", "getWordBounds", "regex", "match", "isTextCommentedExact", "str", "start", "end", "scanForFirst", "fromLine", "fromCh", "marker", "opposite", "direction", "markerTrim", "oppositeTrim", "l", "searchStart", "idx", "isComment", "commentStartPos", "commentEndPos", "beforeType", "afterType", "startLine", "endLineIdx", "endChIdx", "endLine", "spaceAdjust", "toLine", "newText", "newCursorLine", "newCursorCh", "lastLine", "lineLen", "clamped", "useWord", "removalUsedStart", "removalUsedEnd", "removalInside", "removalCheckText", "style", "lineStart", "lineEnd", "removeNearestMarkersFromWordOrSelection", "selectionStart", "selectionEnd", "usedStart", "usedEnd", "inside", "checkText", "uncommented", "removedStartLen", "selFrom", "selTo", "newCh", "commented", "startOffset", "finalCursor", "startIdx", "endIdx", "isInside"]
}
